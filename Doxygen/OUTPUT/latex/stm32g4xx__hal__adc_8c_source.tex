\doxysection{stm32g4xx\+\_\+hal\+\_\+adc.\+c}
\label{stm32g4xx__hal__adc_8c_source}\index{/home/yule/Documents/ENSEA/Ensea\_2022-\/2023/Actionneur\_et\_automatique/TP\_actionneur/TP\_actionneur/Drivers/STM32G4xx\_HAL\_Driver/Src/stm32g4xx\_hal\_adc.c@{/home/yule/Documents/ENSEA/Ensea\_2022-\/2023/Actionneur\_et\_automatique/TP\_actionneur/TP\_actionneur/Drivers/STM32G4xx\_HAL\_Driver/Src/stm32g4xx\_hal\_adc.c}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 }
\DoxyCodeLine{00296 \textcolor{comment}{/* Includes -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00297 \textcolor{preprocessor}{\#include "{}stm32g4xx\_hal.h"{}}}
\DoxyCodeLine{00298 }
\DoxyCodeLine{00308 \textcolor{preprocessor}{\#ifdef HAL\_ADC\_MODULE\_ENABLED}}
\DoxyCodeLine{00309 }
\DoxyCodeLine{00310 \textcolor{comment}{/* Private typedef -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00311 \textcolor{comment}{/* Private define -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00312 }
\DoxyCodeLine{00317 \textcolor{preprocessor}{\#define ADC\_CFGR\_FIELDS\_1  ((ADC\_CFGR\_RES    | ADC\_CFGR\_ALIGN   |\(\backslash\)}}
\DoxyCodeLine{00318 \textcolor{preprocessor}{                             ADC\_CFGR\_CONT   | ADC\_CFGR\_OVRMOD  |\(\backslash\)}}
\DoxyCodeLine{00319 \textcolor{preprocessor}{                             ADC\_CFGR\_DISCEN | ADC\_CFGR\_DISCNUM |\(\backslash\)}}
\DoxyCodeLine{00320 \textcolor{preprocessor}{                             ADC\_CFGR\_EXTEN  | ADC\_CFGR\_EXTSEL))   }}
\DoxyCodeLine{00322 \textcolor{comment}{/* Timeout values for ADC operations (enable settling time,                   */}}
\DoxyCodeLine{00323 \textcolor{comment}{/*   disable settling time, ...).                                             */}}
\DoxyCodeLine{00324 \textcolor{comment}{/*   Values defined to be higher than worst cases: low clock frequency,       */}}
\DoxyCodeLine{00325 \textcolor{comment}{/*   maximum prescalers.                                                      */}}
\DoxyCodeLine{00326 \textcolor{preprocessor}{\#define ADC\_ENABLE\_TIMEOUT              (2UL)    }}
\DoxyCodeLine{00327 \textcolor{preprocessor}{\#define ADC\_DISABLE\_TIMEOUT             (2UL)    }}
\DoxyCodeLine{00329 \textcolor{comment}{/* Timeout to wait for current conversion on going to be completed.           */}}
\DoxyCodeLine{00330 \textcolor{comment}{/* Timeout fixed to longest ADC conversion possible, for 1 channel:           */}}
\DoxyCodeLine{00331 \textcolor{comment}{/*   -\/ maximum sampling time (640.5 adc\_clk)                                  */}}
\DoxyCodeLine{00332 \textcolor{comment}{/*   -\/ ADC resolution (Tsar 12 bits= 12.5 adc\_clk)                            */}}
\DoxyCodeLine{00333 \textcolor{comment}{/*   -\/ System clock / ADC clock <= 4096 (hypothesis of maximum clock ratio)   */}}
\DoxyCodeLine{00334 \textcolor{comment}{/*   -\/ ADC oversampling ratio 256                                             */}}
\DoxyCodeLine{00335 \textcolor{comment}{/*   Calculation: 653 * 4096 * 256 CPU clock cycles max                       */}}
\DoxyCodeLine{00336 \textcolor{comment}{/* Unit: cycles of CPU clock.                                                 */}}
\DoxyCodeLine{00337 \textcolor{preprocessor}{\#define ADC\_CONVERSION\_TIME\_MAX\_CPU\_CYCLES (653UL * 4096UL * 256UL)  }}
\DoxyCodeLine{00344 \textcolor{comment}{/* Private macro -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00345 \textcolor{comment}{/* Private variables -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00346 \textcolor{comment}{/* Private function prototypes -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00347 \textcolor{comment}{/* Exported functions -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*/}}
\DoxyCodeLine{00348 }
\DoxyCodeLine{00395 HAL\_StatusTypeDef HAL\_ADC\_Init(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{00396 \{}
\DoxyCodeLine{00397   HAL\_StatusTypeDef tmp\_hal\_status = HAL\_OK;}
\DoxyCodeLine{00398   uint32\_t tmpCFGR;}
\DoxyCodeLine{00399   uint32\_t tmp\_adc\_reg\_is\_conversion\_on\_going;}
\DoxyCodeLine{00400   \_\_IO uint32\_t wait\_loop\_index = 0UL;}
\DoxyCodeLine{00401   uint32\_t tmp\_adc\_is\_conversion\_on\_going\_regular;}
\DoxyCodeLine{00402   uint32\_t tmp\_adc\_is\_conversion\_on\_going\_injected;}
\DoxyCodeLine{00403 }
\DoxyCodeLine{00404   \textcolor{comment}{/* Check ADC handle */}}
\DoxyCodeLine{00405   \textcolor{keywordflow}{if} (hadc == NULL)}
\DoxyCodeLine{00406   \{}
\DoxyCodeLine{00407     \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{00408   \}}
\DoxyCodeLine{00409 }
\DoxyCodeLine{00410   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{00411   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{00412   assert\_param(IS\_ADC\_CLOCKPRESCALER(hadc-\/>Init.ClockPrescaler));}
\DoxyCodeLine{00413   assert\_param(IS\_ADC\_RESOLUTION(hadc-\/>Init.Resolution));}
\DoxyCodeLine{00414   assert\_param(IS\_ADC\_DATA\_ALIGN(hadc-\/>Init.DataAlign));}
\DoxyCodeLine{00415   assert\_param(IS\_ADC\_GAIN\_COMPENSATION(hadc-\/>Init.GainCompensation));}
\DoxyCodeLine{00416   assert\_param(IS\_ADC\_SCAN\_MODE(hadc-\/>Init.ScanConvMode));}
\DoxyCodeLine{00417   assert\_param(IS\_FUNCTIONAL\_STATE(hadc-\/>Init.ContinuousConvMode));}
\DoxyCodeLine{00418   assert\_param(IS\_ADC\_EXTTRIG\_EDGE(hadc-\/>Init.ExternalTrigConvEdge));}
\DoxyCodeLine{00419   assert\_param(IS\_ADC\_EXTTRIG(hadc, hadc-\/>Init.ExternalTrigConv));}
\DoxyCodeLine{00420   assert\_param(IS\_ADC\_SAMPLINGMODE(hadc-\/>Init.SamplingMode));}
\DoxyCodeLine{00421   assert\_param(IS\_FUNCTIONAL\_STATE(hadc-\/>Init.DMAContinuousRequests));}
\DoxyCodeLine{00422   assert\_param(IS\_ADC\_EOC\_SELECTION(hadc-\/>Init.EOCSelection));}
\DoxyCodeLine{00423   assert\_param(IS\_ADC\_OVERRUN(hadc-\/>Init.Overrun));}
\DoxyCodeLine{00424   assert\_param(IS\_FUNCTIONAL\_STATE(hadc-\/>Init.LowPowerAutoWait));}
\DoxyCodeLine{00425   assert\_param(IS\_FUNCTIONAL\_STATE(hadc-\/>Init.OversamplingMode));}
\DoxyCodeLine{00426 }
\DoxyCodeLine{00427   \textcolor{keywordflow}{if} (hadc-\/>Init.ScanConvMode != ADC\_SCAN\_DISABLE)}
\DoxyCodeLine{00428   \{}
\DoxyCodeLine{00429     assert\_param(IS\_ADC\_REGULAR\_NB\_CONV(hadc-\/>Init.NbrOfConversion));}
\DoxyCodeLine{00430     assert\_param(IS\_FUNCTIONAL\_STATE(hadc-\/>Init.DiscontinuousConvMode));}
\DoxyCodeLine{00431 }
\DoxyCodeLine{00432     \textcolor{keywordflow}{if} (hadc-\/>Init.DiscontinuousConvMode == ENABLE)}
\DoxyCodeLine{00433     \{}
\DoxyCodeLine{00434       assert\_param(IS\_ADC\_REGULAR\_DISCONT\_NUMBER(hadc-\/>Init.NbrOfDiscConversion));}
\DoxyCodeLine{00435     \}}
\DoxyCodeLine{00436   \}}
\DoxyCodeLine{00437 }
\DoxyCodeLine{00438   \textcolor{comment}{/* DISCEN and CONT bits cannot be set at the same time */}}
\DoxyCodeLine{00439   assert\_param(!((hadc-\/>Init.DiscontinuousConvMode == ENABLE) \&\& (hadc-\/>Init.ContinuousConvMode == ENABLE)));}
\DoxyCodeLine{00440 }
\DoxyCodeLine{00441   \textcolor{comment}{/* Actions performed only if ADC is coming from state reset:                */}}
\DoxyCodeLine{00442   \textcolor{comment}{/* -\/ Initialization of ADC MSP                                              */}}
\DoxyCodeLine{00443   \textcolor{keywordflow}{if} (hadc-\/>State == HAL\_ADC\_STATE\_RESET)}
\DoxyCodeLine{00444   \{}
\DoxyCodeLine{00445 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{00446     \textcolor{comment}{/* Init the ADC Callback settings */}}
\DoxyCodeLine{00447     hadc-\/>ConvCpltCallback              = HAL\_ADC\_ConvCpltCallback;                 \textcolor{comment}{/* Legacy weak callback */}}
\DoxyCodeLine{00448     hadc-\/>ConvHalfCpltCallback          = HAL\_ADC\_ConvHalfCpltCallback;             \textcolor{comment}{/* Legacy weak callback */}}
\DoxyCodeLine{00449     hadc-\/>LevelOutOfWindowCallback      = HAL\_ADC\_LevelOutOfWindowCallback;         \textcolor{comment}{/* Legacy weak callback */}}
\DoxyCodeLine{00450     hadc-\/>ErrorCallback                 = HAL\_ADC\_ErrorCallback;                    \textcolor{comment}{/* Legacy weak callback */}}
\DoxyCodeLine{00451     hadc-\/>InjectedConvCpltCallback      = HAL\_ADCEx\_InjectedConvCpltCallback;       \textcolor{comment}{/* Legacy weak callback */}}
\DoxyCodeLine{00452     hadc-\/>InjectedQueueOverflowCallback = HAL\_ADCEx\_InjectedQueueOverflowCallback;  \textcolor{comment}{/* Legacy weak callback */}}
\DoxyCodeLine{00453     hadc-\/>LevelOutOfWindow2Callback     = HAL\_ADCEx\_LevelOutOfWindow2Callback;      \textcolor{comment}{/* Legacy weak callback */}}
\DoxyCodeLine{00454     hadc-\/>LevelOutOfWindow3Callback     = HAL\_ADCEx\_LevelOutOfWindow3Callback;      \textcolor{comment}{/* Legacy weak callback */}}
\DoxyCodeLine{00455     hadc-\/>EndOfSamplingCallback         = HAL\_ADCEx\_EndOfSamplingCallback;          \textcolor{comment}{/* Legacy weak callback */}}
\DoxyCodeLine{00456 }
\DoxyCodeLine{00457     \textcolor{keywordflow}{if} (hadc-\/>MspInitCallback == NULL)}
\DoxyCodeLine{00458     \{}
\DoxyCodeLine{00459       hadc-\/>MspInitCallback = HAL\_ADC\_MspInit; \textcolor{comment}{/* Legacy weak MspInit  */}}
\DoxyCodeLine{00460     \}}
\DoxyCodeLine{00461 }
\DoxyCodeLine{00462     \textcolor{comment}{/* Init the low level hardware */}}
\DoxyCodeLine{00463     hadc-\/>MspInitCallback(hadc);}
\DoxyCodeLine{00464 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00465     \textcolor{comment}{/* Init the low level hardware */}}
\DoxyCodeLine{00466     HAL\_ADC\_MspInit(hadc);}
\DoxyCodeLine{00467 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00468 }
\DoxyCodeLine{00469     \textcolor{comment}{/* Set ADC error code to none */}}
\DoxyCodeLine{00470     ADC\_CLEAR\_ERRORCODE(hadc);}
\DoxyCodeLine{00471 }
\DoxyCodeLine{00472     \textcolor{comment}{/* Initialize Lock */}}
\DoxyCodeLine{00473     hadc-\/>Lock = HAL\_UNLOCKED;}
\DoxyCodeLine{00474   \}}
\DoxyCodeLine{00475 }
\DoxyCodeLine{00476   \textcolor{comment}{/* -\/ Exit from deep-\/power-\/down mode and ADC voltage regulator enable        */}}
\DoxyCodeLine{00477   \textcolor{keywordflow}{if} (LL\_ADC\_IsDeepPowerDownEnabled(hadc-\/>Instance) != 0UL)}
\DoxyCodeLine{00478   \{}
\DoxyCodeLine{00479     \textcolor{comment}{/* Disable ADC deep power down mode */}}
\DoxyCodeLine{00480     LL\_ADC\_DisableDeepPowerDown(hadc-\/>Instance);}
\DoxyCodeLine{00481 }
\DoxyCodeLine{00482     \textcolor{comment}{/* System was in deep power down mode, calibration must}}
\DoxyCodeLine{00483 \textcolor{comment}{     be relaunched or a previously saved calibration factor}}
\DoxyCodeLine{00484 \textcolor{comment}{     re-\/applied once the ADC voltage regulator is enabled */}}
\DoxyCodeLine{00485   \}}
\DoxyCodeLine{00486 }
\DoxyCodeLine{00487   \textcolor{keywordflow}{if} (LL\_ADC\_IsInternalRegulatorEnabled(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{00488   \{}
\DoxyCodeLine{00489     \textcolor{comment}{/* Enable ADC internal voltage regulator */}}
\DoxyCodeLine{00490     LL\_ADC\_EnableInternalRegulator(hadc-\/>Instance);}
\DoxyCodeLine{00491 }
\DoxyCodeLine{00492     \textcolor{comment}{/* Note: Variable divided by 2 to compensate partially              */}}
\DoxyCodeLine{00493     \textcolor{comment}{/*       CPU processing cycles, scaling in us split to not          */}}
\DoxyCodeLine{00494     \textcolor{comment}{/*       exceed 32 bits register capacity and handle low frequency. */}}
\DoxyCodeLine{00495     wait\_loop\_index = ((LL\_ADC\_DELAY\_INTERNAL\_REGUL\_STAB\_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));}
\DoxyCodeLine{00496     \textcolor{keywordflow}{while} (wait\_loop\_index != 0UL)}
\DoxyCodeLine{00497     \{}
\DoxyCodeLine{00498       wait\_loop\_index-\/-\/;}
\DoxyCodeLine{00499     \}}
\DoxyCodeLine{00500   \}}
\DoxyCodeLine{00501 }
\DoxyCodeLine{00502   \textcolor{comment}{/* Verification that ADC voltage regulator is correctly enabled, whether    */}}
\DoxyCodeLine{00503   \textcolor{comment}{/* or not ADC is coming from state reset (if any potential problem of       */}}
\DoxyCodeLine{00504   \textcolor{comment}{/* clocking, voltage regulator would not be enabled).                       */}}
\DoxyCodeLine{00505   \textcolor{keywordflow}{if} (LL\_ADC\_IsInternalRegulatorEnabled(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{00506   \{}
\DoxyCodeLine{00507     \textcolor{comment}{/* Update ADC state machine to error */}}
\DoxyCodeLine{00508     SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_INTERNAL);}
\DoxyCodeLine{00509 }
\DoxyCodeLine{00510     \textcolor{comment}{/* Set ADC error code to ADC peripheral internal error */}}
\DoxyCodeLine{00511     SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_INTERNAL);}
\DoxyCodeLine{00512 }
\DoxyCodeLine{00513     tmp\_hal\_status = HAL\_ERROR;}
\DoxyCodeLine{00514   \}}
\DoxyCodeLine{00515 }
\DoxyCodeLine{00516   \textcolor{comment}{/* Configuration of ADC parameters if previous preliminary actions are      */}}
\DoxyCodeLine{00517   \textcolor{comment}{/* correctly completed and if there is no conversion on going on regular    */}}
\DoxyCodeLine{00518   \textcolor{comment}{/* group (ADC may already be enabled at this point if HAL\_ADC\_Init() is     */}}
\DoxyCodeLine{00519   \textcolor{comment}{/* called to update a parameter on the fly).                                */}}
\DoxyCodeLine{00520   tmp\_adc\_reg\_is\_conversion\_on\_going = LL\_ADC\_REG\_IsConversionOngoing(hadc-\/>Instance);}
\DoxyCodeLine{00521 }
\DoxyCodeLine{00522   \textcolor{keywordflow}{if} (((hadc-\/>State \& HAL\_ADC\_STATE\_ERROR\_INTERNAL) == 0UL)}
\DoxyCodeLine{00523       \&\& (tmp\_adc\_reg\_is\_conversion\_on\_going == 0UL)}
\DoxyCodeLine{00524      )}
\DoxyCodeLine{00525   \{}
\DoxyCodeLine{00526     \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{00527     ADC\_STATE\_CLR\_SET(hadc-\/>State,}
\DoxyCodeLine{00528                       HAL\_ADC\_STATE\_REG\_BUSY,}
\DoxyCodeLine{00529                       HAL\_ADC\_STATE\_BUSY\_INTERNAL);}
\DoxyCodeLine{00530 }
\DoxyCodeLine{00531     \textcolor{comment}{/* Configuration of common ADC parameters                                 */}}
\DoxyCodeLine{00532 }
\DoxyCodeLine{00533     \textcolor{comment}{/* Parameters update conditioned to ADC state:                            */}}
\DoxyCodeLine{00534     \textcolor{comment}{/* Parameters that can be updated only when ADC is disabled:              */}}
\DoxyCodeLine{00535     \textcolor{comment}{/*  -\/ clock configuration                                                 */}}
\DoxyCodeLine{00536     \textcolor{keywordflow}{if} (LL\_ADC\_IsEnabled(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{00537     \{}
\DoxyCodeLine{00538       \textcolor{keywordflow}{if} (\_\_LL\_ADC\_IS\_ENABLED\_ALL\_COMMON\_INSTANCE(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance)) == 0UL)}
\DoxyCodeLine{00539       \{}
\DoxyCodeLine{00540         \textcolor{comment}{/* Reset configuration of ADC common register CCR:                      */}}
\DoxyCodeLine{00541         \textcolor{comment}{/*                                                                      */}}
\DoxyCodeLine{00542         \textcolor{comment}{/*   -\/ ADC clock mode and ACC prescaler (CKMODE and PRESC bits)are set  */}}
\DoxyCodeLine{00543         \textcolor{comment}{/*     according to adc-\/>Init.ClockPrescaler. It selects the clock      */}}
\DoxyCodeLine{00544         \textcolor{comment}{/*    source and sets the clock division factor.                        */}}
\DoxyCodeLine{00545         \textcolor{comment}{/*                                                                      */}}
\DoxyCodeLine{00546         \textcolor{comment}{/* Some parameters of this register are not reset, since they are set   */}}
\DoxyCodeLine{00547         \textcolor{comment}{/* by other functions and must be kept in case of usage of this         */}}
\DoxyCodeLine{00548         \textcolor{comment}{/* function on the fly (update of a parameter of ADC\_InitTypeDef        */}}
\DoxyCodeLine{00549         \textcolor{comment}{/* without needing to reconfigure all other ADC groups/channels         */}}
\DoxyCodeLine{00550         \textcolor{comment}{/* parameters):                                                         */}}
\DoxyCodeLine{00551         \textcolor{comment}{/*   -\/ when multimode feature is available, multimode-\/related           */}}
\DoxyCodeLine{00552         \textcolor{comment}{/*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */}}
\DoxyCodeLine{00553         \textcolor{comment}{/*     HAL\_ADCEx\_MultiModeConfigChannel() )                             */}}
\DoxyCodeLine{00554         \textcolor{comment}{/*   -\/ internal measurement paths: Vbat, temperature sensor, Vref       */}}
\DoxyCodeLine{00555         \textcolor{comment}{/*     (set into HAL\_ADC\_ConfigChannel() or                             */}}
\DoxyCodeLine{00556         \textcolor{comment}{/*     HAL\_ADCEx\_InjectedConfigChannel() )                              */}}
\DoxyCodeLine{00557         LL\_ADC\_SetCommonClock(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance), hadc-\/>Init.ClockPrescaler);}
\DoxyCodeLine{00558       \}}
\DoxyCodeLine{00559     \}}
\DoxyCodeLine{00560 }
\DoxyCodeLine{00561     \textcolor{comment}{/* Configuration of ADC:                                                  */}}
\DoxyCodeLine{00562     \textcolor{comment}{/*  -\/ resolution                               Init.Resolution            */}}
\DoxyCodeLine{00563     \textcolor{comment}{/*  -\/ data alignment                           Init.DataAlign             */}}
\DoxyCodeLine{00564     \textcolor{comment}{/*  -\/ external trigger to start conversion     Init.ExternalTrigConv      */}}
\DoxyCodeLine{00565     \textcolor{comment}{/*  -\/ external trigger polarity                Init.ExternalTrigConvEdge  */}}
\DoxyCodeLine{00566     \textcolor{comment}{/*  -\/ continuous conversion mode               Init.ContinuousConvMode    */}}
\DoxyCodeLine{00567     \textcolor{comment}{/*  -\/ overrun                                  Init.Overrun               */}}
\DoxyCodeLine{00568     \textcolor{comment}{/*  -\/ discontinuous mode                       Init.DiscontinuousConvMode */}}
\DoxyCodeLine{00569     \textcolor{comment}{/*  -\/ discontinuous mode channel count         Init.NbrOfDiscConversion   */}}
\DoxyCodeLine{00570     tmpCFGR  = (ADC\_CFGR\_CONTINUOUS((uint32\_t)hadc-\/>Init.ContinuousConvMode)           |}
\DoxyCodeLine{00571                 hadc-\/>Init.Overrun                                                     |}
\DoxyCodeLine{00572                 hadc-\/>Init.DataAlign                                                   |}
\DoxyCodeLine{00573                 hadc-\/>Init.Resolution                                                  |}
\DoxyCodeLine{00574                 ADC\_CFGR\_REG\_DISCONTINUOUS((uint32\_t)hadc-\/>Init.DiscontinuousConvMode));}
\DoxyCodeLine{00575 }
\DoxyCodeLine{00576     \textcolor{keywordflow}{if} (hadc-\/>Init.DiscontinuousConvMode == ENABLE)}
\DoxyCodeLine{00577     \{}
\DoxyCodeLine{00578       tmpCFGR |= ADC\_CFGR\_DISCONTINUOUS\_NUM(hadc-\/>Init.NbrOfDiscConversion);}
\DoxyCodeLine{00579     \}}
\DoxyCodeLine{00580 }
\DoxyCodeLine{00581     \textcolor{comment}{/* Enable external trigger if trigger selection is different of software  */}}
\DoxyCodeLine{00582     \textcolor{comment}{/* start.                                                                 */}}
\DoxyCodeLine{00583     \textcolor{comment}{/* Note: This configuration keeps the hardware feature of parameter       */}}
\DoxyCodeLine{00584     \textcolor{comment}{/*       ExternalTrigConvEdge "{}trigger edge none"{} equivalent to           */}}
\DoxyCodeLine{00585     \textcolor{comment}{/*       software start.                                                  */}}
\DoxyCodeLine{00586     \textcolor{keywordflow}{if} (hadc-\/>Init.ExternalTrigConv != ADC\_SOFTWARE\_START)}
\DoxyCodeLine{00587     \{}
\DoxyCodeLine{00588       tmpCFGR |= ((hadc-\/>Init.ExternalTrigConv \& ADC\_CFGR\_EXTSEL)}
\DoxyCodeLine{00589                   | hadc-\/>Init.ExternalTrigConvEdge}
\DoxyCodeLine{00590                  );}
\DoxyCodeLine{00591     \}}
\DoxyCodeLine{00592 }
\DoxyCodeLine{00593     \textcolor{comment}{/* Update Configuration Register CFGR */}}
\DoxyCodeLine{00594     MODIFY\_REG(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_FIELDS\_1, tmpCFGR);}
\DoxyCodeLine{00595 }
\DoxyCodeLine{00596     \textcolor{comment}{/* Configuration of sampling mode */}}
\DoxyCodeLine{00597     MODIFY\_REG(hadc-\/>Instance-\/>CFGR2, ADC\_CFGR2\_BULB | ADC\_CFGR2\_SMPTRIG, hadc-\/>Init.SamplingMode);}
\DoxyCodeLine{00598 }
\DoxyCodeLine{00599     \textcolor{comment}{/* Parameters update conditioned to ADC state:                            */}}
\DoxyCodeLine{00600     \textcolor{comment}{/* Parameters that can be updated when ADC is disabled or enabled without */}}
\DoxyCodeLine{00601     \textcolor{comment}{/* conversion on going on regular and injected groups:                    */}}
\DoxyCodeLine{00602     \textcolor{comment}{/*  -\/ Gain Compensation               Init.GainCompensation               */}}
\DoxyCodeLine{00603     \textcolor{comment}{/*  -\/ DMA continuous request          Init.DMAContinuousRequests          */}}
\DoxyCodeLine{00604     \textcolor{comment}{/*  -\/ LowPowerAutoWait feature        Init.LowPowerAutoWait               */}}
\DoxyCodeLine{00605     \textcolor{comment}{/*  -\/ Oversampling parameters         Init.Oversampling                   */}}
\DoxyCodeLine{00606     tmp\_adc\_is\_conversion\_on\_going\_regular = LL\_ADC\_REG\_IsConversionOngoing(hadc-\/>Instance);}
\DoxyCodeLine{00607     tmp\_adc\_is\_conversion\_on\_going\_injected = LL\_ADC\_INJ\_IsConversionOngoing(hadc-\/>Instance);}
\DoxyCodeLine{00608     \textcolor{keywordflow}{if} ((tmp\_adc\_is\_conversion\_on\_going\_regular == 0UL)}
\DoxyCodeLine{00609         \&\& (tmp\_adc\_is\_conversion\_on\_going\_injected == 0UL)}
\DoxyCodeLine{00610        )}
\DoxyCodeLine{00611     \{}
\DoxyCodeLine{00612       tmpCFGR = (ADC\_CFGR\_DFSDM(hadc)                                            |}
\DoxyCodeLine{00613                  ADC\_CFGR\_AUTOWAIT((uint32\_t)hadc-\/>Init.LowPowerAutoWait)        |}
\DoxyCodeLine{00614                  ADC\_CFGR\_DMACONTREQ((uint32\_t)hadc-\/>Init.DMAContinuousRequests));}
\DoxyCodeLine{00615 }
\DoxyCodeLine{00616       MODIFY\_REG(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_FIELDS\_2, tmpCFGR);}
\DoxyCodeLine{00617 }
\DoxyCodeLine{00618       \textcolor{keywordflow}{if} (hadc-\/>Init.GainCompensation != 0UL)}
\DoxyCodeLine{00619       \{}
\DoxyCodeLine{00620         SET\_BIT(hadc-\/>Instance-\/>CFGR2, ADC\_CFGR2\_GCOMP);}
\DoxyCodeLine{00621         MODIFY\_REG(hadc-\/>Instance-\/>GCOMP, ADC\_GCOMP\_GCOMPCOEFF, hadc-\/>Init.GainCompensation);}
\DoxyCodeLine{00622       \}}
\DoxyCodeLine{00623       \textcolor{keywordflow}{else}}
\DoxyCodeLine{00624       \{}
\DoxyCodeLine{00625         CLEAR\_BIT(hadc-\/>Instance-\/>CFGR2, ADC\_CFGR2\_GCOMP);}
\DoxyCodeLine{00626         MODIFY\_REG(hadc-\/>Instance-\/>GCOMP, ADC\_GCOMP\_GCOMPCOEFF, 0UL);}
\DoxyCodeLine{00627       \}}
\DoxyCodeLine{00628 }
\DoxyCodeLine{00629       \textcolor{keywordflow}{if} (hadc-\/>Init.OversamplingMode == ENABLE)}
\DoxyCodeLine{00630       \{}
\DoxyCodeLine{00631         assert\_param(IS\_ADC\_OVERSAMPLING\_RATIO(hadc-\/>Init.Oversampling.Ratio));}
\DoxyCodeLine{00632         assert\_param(IS\_ADC\_RIGHT\_BIT\_SHIFT(hadc-\/>Init.Oversampling.RightBitShift));}
\DoxyCodeLine{00633         assert\_param(IS\_ADC\_TRIGGERED\_OVERSAMPLING\_MODE(hadc-\/>Init.Oversampling.TriggeredMode));}
\DoxyCodeLine{00634         assert\_param(IS\_ADC\_REGOVERSAMPLING\_MODE(hadc-\/>Init.Oversampling.OversamplingStopReset));}
\DoxyCodeLine{00635 }
\DoxyCodeLine{00636         \textcolor{comment}{/* Configuration of Oversampler:                                      */}}
\DoxyCodeLine{00637         \textcolor{comment}{/*  -\/ Oversampling Ratio                                              */}}
\DoxyCodeLine{00638         \textcolor{comment}{/*  -\/ Right bit shift                                                 */}}
\DoxyCodeLine{00639         \textcolor{comment}{/*  -\/ Triggered mode                                                  */}}
\DoxyCodeLine{00640         \textcolor{comment}{/*  -\/ Oversampling mode (continued/resumed)                           */}}
\DoxyCodeLine{00641         MODIFY\_REG(hadc-\/>Instance-\/>CFGR2,}
\DoxyCodeLine{00642                    ADC\_CFGR2\_OVSR  |}
\DoxyCodeLine{00643                    ADC\_CFGR2\_OVSS  |}
\DoxyCodeLine{00644                    ADC\_CFGR2\_TROVS |}
\DoxyCodeLine{00645                    ADC\_CFGR2\_ROVSM,}
\DoxyCodeLine{00646                    ADC\_CFGR2\_ROVSE                       |}
\DoxyCodeLine{00647                    hadc-\/>Init.Oversampling.Ratio         |}
\DoxyCodeLine{00648                    hadc-\/>Init.Oversampling.RightBitShift |}
\DoxyCodeLine{00649                    hadc-\/>Init.Oversampling.TriggeredMode |}
\DoxyCodeLine{00650                    hadc-\/>Init.Oversampling.OversamplingStopReset}
\DoxyCodeLine{00651                   );}
\DoxyCodeLine{00652       \}}
\DoxyCodeLine{00653       \textcolor{keywordflow}{else}}
\DoxyCodeLine{00654       \{}
\DoxyCodeLine{00655         \textcolor{comment}{/* Disable ADC oversampling scope on ADC group regular */}}
\DoxyCodeLine{00656         CLEAR\_BIT(hadc-\/>Instance-\/>CFGR2, ADC\_CFGR2\_ROVSE);}
\DoxyCodeLine{00657       \}}
\DoxyCodeLine{00658 }
\DoxyCodeLine{00659     \}}
\DoxyCodeLine{00660 }
\DoxyCodeLine{00661     \textcolor{comment}{/* Configuration of regular group sequencer:                              */}}
\DoxyCodeLine{00662     \textcolor{comment}{/* -\/ if scan mode is disabled, regular channels sequence length is set to */}}
\DoxyCodeLine{00663     \textcolor{comment}{/*   0x00: 1 channel converted (channel on regular rank 1)                */}}
\DoxyCodeLine{00664     \textcolor{comment}{/*   Parameter "{}NbrOfConversion"{} is discarded.                            */}}
\DoxyCodeLine{00665     \textcolor{comment}{/*   Note: Scan mode is not present by hardware on this device, but       */}}
\DoxyCodeLine{00666     \textcolor{comment}{/*   emulated by software for alignment over all STM32 devices.           */}}
\DoxyCodeLine{00667     \textcolor{comment}{/* -\/ if scan mode is enabled, regular channels sequence length is set to  */}}
\DoxyCodeLine{00668     \textcolor{comment}{/*   parameter "{}NbrOfConversion"{}.                                         */}}
\DoxyCodeLine{00669 }
\DoxyCodeLine{00670     \textcolor{keywordflow}{if} (hadc-\/>Init.ScanConvMode == ADC\_SCAN\_ENABLE)}
\DoxyCodeLine{00671     \{}
\DoxyCodeLine{00672       \textcolor{comment}{/* Set number of ranks in regular group sequencer */}}
\DoxyCodeLine{00673       MODIFY\_REG(hadc-\/>Instance-\/>SQR1, ADC\_SQR1\_L, (hadc-\/>Init.NbrOfConversion -\/ (uint8\_t)1));}
\DoxyCodeLine{00674     \}}
\DoxyCodeLine{00675     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00676     \{}
\DoxyCodeLine{00677       CLEAR\_BIT(hadc-\/>Instance-\/>SQR1, ADC\_SQR1\_L);}
\DoxyCodeLine{00678     \}}
\DoxyCodeLine{00679 }
\DoxyCodeLine{00680     \textcolor{comment}{/* Initialize the ADC state */}}
\DoxyCodeLine{00681     \textcolor{comment}{/* Clear HAL\_ADC\_STATE\_BUSY\_INTERNAL bit, set HAL\_ADC\_STATE\_READY bit */}}
\DoxyCodeLine{00682     ADC\_STATE\_CLR\_SET(hadc-\/>State, HAL\_ADC\_STATE\_BUSY\_INTERNAL, HAL\_ADC\_STATE\_READY);}
\DoxyCodeLine{00683   \}}
\DoxyCodeLine{00684   \textcolor{keywordflow}{else}}
\DoxyCodeLine{00685   \{}
\DoxyCodeLine{00686     \textcolor{comment}{/* Update ADC state machine to error */}}
\DoxyCodeLine{00687     SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_INTERNAL);}
\DoxyCodeLine{00688 }
\DoxyCodeLine{00689     tmp\_hal\_status = HAL\_ERROR;}
\DoxyCodeLine{00690   \}}
\DoxyCodeLine{00691 }
\DoxyCodeLine{00692   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{00693   \textcolor{keywordflow}{return} tmp\_hal\_status;}
\DoxyCodeLine{00694 \}}
\DoxyCodeLine{00695 }
\DoxyCodeLine{00714 HAL\_StatusTypeDef HAL\_ADC\_DeInit(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{00715 \{}
\DoxyCodeLine{00716   HAL\_StatusTypeDef tmp\_hal\_status;}
\DoxyCodeLine{00717 }
\DoxyCodeLine{00718   \textcolor{comment}{/* Check ADC handle */}}
\DoxyCodeLine{00719   \textcolor{keywordflow}{if} (hadc == NULL)}
\DoxyCodeLine{00720   \{}
\DoxyCodeLine{00721     \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{00722   \}}
\DoxyCodeLine{00723 }
\DoxyCodeLine{00724   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{00725   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{00726 }
\DoxyCodeLine{00727   \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{00728   SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_BUSY\_INTERNAL);}
\DoxyCodeLine{00729 }
\DoxyCodeLine{00730   \textcolor{comment}{/* Stop potential conversion on going */}}
\DoxyCodeLine{00731   tmp\_hal\_status = ADC\_ConversionStop(hadc, ADC\_REGULAR\_INJECTED\_GROUP);}
\DoxyCodeLine{00732 }
\DoxyCodeLine{00733   \textcolor{comment}{/* Disable ADC peripheral if conversions are effectively stopped            */}}
\DoxyCodeLine{00734   \textcolor{comment}{/* Flush register JSQR: reset the queue sequencer when injected             */}}
\DoxyCodeLine{00735   \textcolor{comment}{/* queue sequencer is enabled and ADC disabled.                             */}}
\DoxyCodeLine{00736   \textcolor{comment}{/* The software and hardware triggers of the injected sequence are both     */}}
\DoxyCodeLine{00737   \textcolor{comment}{/* internally disabled just after the completion of the last valid          */}}
\DoxyCodeLine{00738   \textcolor{comment}{/* injected sequence.                                                       */}}
\DoxyCodeLine{00739   SET\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_JQM);}
\DoxyCodeLine{00740 }
\DoxyCodeLine{00741   \textcolor{comment}{/* Disable ADC peripheral if conversions are effectively stopped */}}
\DoxyCodeLine{00742   \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{00743   \{}
\DoxyCodeLine{00744     \textcolor{comment}{/* Disable the ADC peripheral */}}
\DoxyCodeLine{00745     tmp\_hal\_status = ADC\_Disable(hadc);}
\DoxyCodeLine{00746 }
\DoxyCodeLine{00747     \textcolor{comment}{/* Check if ADC is effectively disabled */}}
\DoxyCodeLine{00748     \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{00749     \{}
\DoxyCodeLine{00750       \textcolor{comment}{/* Change ADC state */}}
\DoxyCodeLine{00751       hadc-\/>State = HAL\_ADC\_STATE\_READY;}
\DoxyCodeLine{00752     \}}
\DoxyCodeLine{00753   \}}
\DoxyCodeLine{00754 }
\DoxyCodeLine{00755   \textcolor{comment}{/* Note: HAL ADC deInit is done independently of ADC conversion stop        */}}
\DoxyCodeLine{00756   \textcolor{comment}{/*       and disable return status. In case of status fail, attempt to      */}}
\DoxyCodeLine{00757   \textcolor{comment}{/*       perform deinitialization anyway and it is up user code in          */}}
\DoxyCodeLine{00758   \textcolor{comment}{/*       in HAL\_ADC\_MspDeInit() to reset the ADC peripheral using           */}}
\DoxyCodeLine{00759   \textcolor{comment}{/*       system RCC hard reset.                                             */}}
\DoxyCodeLine{00760 }
\DoxyCodeLine{00761   \textcolor{comment}{/* ========== Reset ADC registers ========== */}}
\DoxyCodeLine{00762   \textcolor{comment}{/* Reset register IER */}}
\DoxyCodeLine{00763   \_\_HAL\_ADC\_DISABLE\_IT(hadc, (ADC\_IT\_AWD3  | ADC\_IT\_AWD2 | ADC\_IT\_AWD1 |}
\DoxyCodeLine{00764                               ADC\_IT\_JQOVF | ADC\_IT\_OVR  |}
\DoxyCodeLine{00765                               ADC\_IT\_JEOS  | ADC\_IT\_JEOC |}
\DoxyCodeLine{00766                               ADC\_IT\_EOS   | ADC\_IT\_EOC  |}
\DoxyCodeLine{00767                               ADC\_IT\_EOSMP | ADC\_IT\_RDY));}
\DoxyCodeLine{00768 }
\DoxyCodeLine{00769   \textcolor{comment}{/* Reset register ISR */}}
\DoxyCodeLine{00770   \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, (ADC\_FLAG\_AWD3  | ADC\_FLAG\_AWD2 | ADC\_FLAG\_AWD1 |}
\DoxyCodeLine{00771                               ADC\_FLAG\_JQOVF | ADC\_FLAG\_OVR  |}
\DoxyCodeLine{00772                               ADC\_FLAG\_JEOS  | ADC\_FLAG\_JEOC |}
\DoxyCodeLine{00773                               ADC\_FLAG\_EOS   | ADC\_FLAG\_EOC  |}
\DoxyCodeLine{00774                               ADC\_FLAG\_EOSMP | ADC\_FLAG\_RDY));}
\DoxyCodeLine{00775 }
\DoxyCodeLine{00776   \textcolor{comment}{/* Reset register CR */}}
\DoxyCodeLine{00777   \textcolor{comment}{/* Bits ADC\_CR\_JADSTP, ADC\_CR\_ADSTP, ADC\_CR\_JADSTART, ADC\_CR\_ADSTART,}}
\DoxyCodeLine{00778 \textcolor{comment}{     ADC\_CR\_ADCAL, ADC\_CR\_ADDIS and ADC\_CR\_ADEN are in access mode "{}read-\/set"{}:}}
\DoxyCodeLine{00779 \textcolor{comment}{     no direct reset applicable.}}
\DoxyCodeLine{00780 \textcolor{comment}{     Update CR register to reset value where doable by software */}}
\DoxyCodeLine{00781   CLEAR\_BIT(hadc-\/>Instance-\/>CR, ADC\_CR\_ADVREGEN | ADC\_CR\_ADCALDIF);}
\DoxyCodeLine{00782   SET\_BIT(hadc-\/>Instance-\/>CR, ADC\_CR\_DEEPPWD);}
\DoxyCodeLine{00783 }
\DoxyCodeLine{00784   \textcolor{comment}{/* Reset register CFGR */}}
\DoxyCodeLine{00785   CLEAR\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_FIELDS);}
\DoxyCodeLine{00786   SET\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_JQDIS);}
\DoxyCodeLine{00787 }
\DoxyCodeLine{00788   \textcolor{comment}{/* Reset register CFGR2 */}}
\DoxyCodeLine{00789   CLEAR\_BIT(hadc-\/>Instance-\/>CFGR2, ADC\_CFGR2\_ROVSM  | ADC\_CFGR2\_TROVS   | ADC\_CFGR2\_OVSS |}
\DoxyCodeLine{00790             ADC\_CFGR2\_OVSR  | ADC\_CFGR2\_JOVSE | ADC\_CFGR2\_ROVSE);}
\DoxyCodeLine{00791 }
\DoxyCodeLine{00792   \textcolor{comment}{/* Reset register SMPR1 */}}
\DoxyCodeLine{00793   CLEAR\_BIT(hadc-\/>Instance-\/>SMPR1, ADC\_SMPR1\_FIELDS);}
\DoxyCodeLine{00794 }
\DoxyCodeLine{00795   \textcolor{comment}{/* Reset register SMPR2 */}}
\DoxyCodeLine{00796   CLEAR\_BIT(hadc-\/>Instance-\/>SMPR2, ADC\_SMPR2\_SMP18 | ADC\_SMPR2\_SMP17 | ADC\_SMPR2\_SMP16 |}
\DoxyCodeLine{00797             ADC\_SMPR2\_SMP15 | ADC\_SMPR2\_SMP14 | ADC\_SMPR2\_SMP13 |}
\DoxyCodeLine{00798             ADC\_SMPR2\_SMP12 | ADC\_SMPR2\_SMP11 | ADC\_SMPR2\_SMP10);}
\DoxyCodeLine{00799 }
\DoxyCodeLine{00800   \textcolor{comment}{/* Reset register TR1 */}}
\DoxyCodeLine{00801   CLEAR\_BIT(hadc-\/>Instance-\/>TR1, ADC\_TR1\_HT1 | ADC\_TR1\_LT1);}
\DoxyCodeLine{00802 }
\DoxyCodeLine{00803   \textcolor{comment}{/* Reset register TR2 */}}
\DoxyCodeLine{00804   CLEAR\_BIT(hadc-\/>Instance-\/>TR2, ADC\_TR2\_HT2 | ADC\_TR2\_LT2);}
\DoxyCodeLine{00805 }
\DoxyCodeLine{00806   \textcolor{comment}{/* Reset register TR3 */}}
\DoxyCodeLine{00807   CLEAR\_BIT(hadc-\/>Instance-\/>TR3, ADC\_TR3\_HT3 | ADC\_TR3\_LT3);}
\DoxyCodeLine{00808 }
\DoxyCodeLine{00809   \textcolor{comment}{/* Reset register SQR1 */}}
\DoxyCodeLine{00810   CLEAR\_BIT(hadc-\/>Instance-\/>SQR1, ADC\_SQR1\_SQ4 | ADC\_SQR1\_SQ3 | ADC\_SQR1\_SQ2 |}
\DoxyCodeLine{00811             ADC\_SQR1\_SQ1 | ADC\_SQR1\_L);}
\DoxyCodeLine{00812 }
\DoxyCodeLine{00813   \textcolor{comment}{/* Reset register SQR2 */}}
\DoxyCodeLine{00814   CLEAR\_BIT(hadc-\/>Instance-\/>SQR2, ADC\_SQR2\_SQ9 | ADC\_SQR2\_SQ8 | ADC\_SQR2\_SQ7 |}
\DoxyCodeLine{00815             ADC\_SQR2\_SQ6 | ADC\_SQR2\_SQ5);}
\DoxyCodeLine{00816 }
\DoxyCodeLine{00817   \textcolor{comment}{/* Reset register SQR3 */}}
\DoxyCodeLine{00818   CLEAR\_BIT(hadc-\/>Instance-\/>SQR3, ADC\_SQR3\_SQ14 | ADC\_SQR3\_SQ13 | ADC\_SQR3\_SQ12 |}
\DoxyCodeLine{00819             ADC\_SQR3\_SQ11 | ADC\_SQR3\_SQ10);}
\DoxyCodeLine{00820 }
\DoxyCodeLine{00821   \textcolor{comment}{/* Reset register SQR4 */}}
\DoxyCodeLine{00822   CLEAR\_BIT(hadc-\/>Instance-\/>SQR4, ADC\_SQR4\_SQ16 | ADC\_SQR4\_SQ15);}
\DoxyCodeLine{00823 }
\DoxyCodeLine{00824   \textcolor{comment}{/* Register JSQR was reset when the ADC was disabled */}}
\DoxyCodeLine{00825 }
\DoxyCodeLine{00826   \textcolor{comment}{/* Reset register DR */}}
\DoxyCodeLine{00827   \textcolor{comment}{/* bits in access mode read only, no direct reset applicable*/}}
\DoxyCodeLine{00828 }
\DoxyCodeLine{00829   \textcolor{comment}{/* Reset register OFR1 */}}
\DoxyCodeLine{00830   CLEAR\_BIT(hadc-\/>Instance-\/>OFR1, ADC\_OFR1\_OFFSET1\_EN | ADC\_OFR1\_OFFSET1\_CH | ADC\_OFR1\_OFFSET1);}
\DoxyCodeLine{00831   \textcolor{comment}{/* Reset register OFR2 */}}
\DoxyCodeLine{00832   CLEAR\_BIT(hadc-\/>Instance-\/>OFR2, ADC\_OFR2\_OFFSET2\_EN | ADC\_OFR2\_OFFSET2\_CH | ADC\_OFR2\_OFFSET2);}
\DoxyCodeLine{00833   \textcolor{comment}{/* Reset register OFR3 */}}
\DoxyCodeLine{00834   CLEAR\_BIT(hadc-\/>Instance-\/>OFR3, ADC\_OFR3\_OFFSET3\_EN | ADC\_OFR3\_OFFSET3\_CH | ADC\_OFR3\_OFFSET3);}
\DoxyCodeLine{00835   \textcolor{comment}{/* Reset register OFR4 */}}
\DoxyCodeLine{00836   CLEAR\_BIT(hadc-\/>Instance-\/>OFR4, ADC\_OFR4\_OFFSET4\_EN | ADC\_OFR4\_OFFSET4\_CH | ADC\_OFR4\_OFFSET4);}
\DoxyCodeLine{00837 }
\DoxyCodeLine{00838   \textcolor{comment}{/* Reset registers JDR1, JDR2, JDR3, JDR4 */}}
\DoxyCodeLine{00839   \textcolor{comment}{/* bits in access mode read only, no direct reset applicable*/}}
\DoxyCodeLine{00840 }
\DoxyCodeLine{00841   \textcolor{comment}{/* Reset register AWD2CR */}}
\DoxyCodeLine{00842   CLEAR\_BIT(hadc-\/>Instance-\/>AWD2CR, ADC\_AWD2CR\_AWD2CH);}
\DoxyCodeLine{00843 }
\DoxyCodeLine{00844   \textcolor{comment}{/* Reset register AWD3CR */}}
\DoxyCodeLine{00845   CLEAR\_BIT(hadc-\/>Instance-\/>AWD3CR, ADC\_AWD3CR\_AWD3CH);}
\DoxyCodeLine{00846 }
\DoxyCodeLine{00847   \textcolor{comment}{/* Reset register DIFSEL */}}
\DoxyCodeLine{00848   CLEAR\_BIT(hadc-\/>Instance-\/>DIFSEL, ADC\_DIFSEL\_DIFSEL);}
\DoxyCodeLine{00849 }
\DoxyCodeLine{00850   \textcolor{comment}{/* Reset register CALFACT */}}
\DoxyCodeLine{00851   CLEAR\_BIT(hadc-\/>Instance-\/>CALFACT, ADC\_CALFACT\_CALFACT\_D | ADC\_CALFACT\_CALFACT\_S);}
\DoxyCodeLine{00852 }
\DoxyCodeLine{00853 }
\DoxyCodeLine{00854   \textcolor{comment}{/* ========== Reset common ADC registers ========== */}}
\DoxyCodeLine{00855 }
\DoxyCodeLine{00856   \textcolor{comment}{/* Software is allowed to change common parameters only when all the other}}
\DoxyCodeLine{00857 \textcolor{comment}{     ADCs are disabled.   */}}
\DoxyCodeLine{00858   \textcolor{keywordflow}{if} (\_\_LL\_ADC\_IS\_ENABLED\_ALL\_COMMON\_INSTANCE(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance)) == 0UL)}
\DoxyCodeLine{00859   \{}
\DoxyCodeLine{00860     \textcolor{comment}{/* Reset configuration of ADC common register CCR:}}
\DoxyCodeLine{00861 \textcolor{comment}{      -\/ clock mode: CKMODE, PRESCEN}}
\DoxyCodeLine{00862 \textcolor{comment}{      -\/ multimode related parameters (when this feature is available): MDMA,}}
\DoxyCodeLine{00863 \textcolor{comment}{        DMACFG, DELAY, DUAL (set by HAL\_ADCEx\_MultiModeConfigChannel() API)}}
\DoxyCodeLine{00864 \textcolor{comment}{      -\/ internal measurement paths: Vbat, temperature sensor, Vref (set into}}
\DoxyCodeLine{00865 \textcolor{comment}{        HAL\_ADC\_ConfigChannel() or HAL\_ADCEx\_InjectedConfigChannel() )}}
\DoxyCodeLine{00866 \textcolor{comment}{    */}}
\DoxyCodeLine{00867     ADC\_CLEAR\_COMMON\_CONTROL\_REGISTER(hadc);}
\DoxyCodeLine{00868 }
\DoxyCodeLine{00869     \textcolor{comment}{/* ========== Hard reset ADC peripheral ========== */}}
\DoxyCodeLine{00870     \textcolor{comment}{/* Performs a global reset of the entire ADC peripherals instances        */}}
\DoxyCodeLine{00871     \textcolor{comment}{/* sharing the same common ADC instance: ADC state is forced to           */}}
\DoxyCodeLine{00872     \textcolor{comment}{/* a similar state as after device power-\/on.                              */}}
\DoxyCodeLine{00873     \textcolor{comment}{/* Note: A possible implementation is to add RCC bus reset of ADC         */}}
\DoxyCodeLine{00874     \textcolor{comment}{/* (for example, using macro                                              */}}
\DoxyCodeLine{00875     \textcolor{comment}{/*  \_\_HAL\_RCC\_ADC...\_FORCE\_RESET()/...\_RELEASE\_RESET()/...\_CLK\_DISABLE()) */}}
\DoxyCodeLine{00876     \textcolor{comment}{/* in function "{}void HAL\_ADC\_MspDeInit(ADC\_HandleTypeDef *hadc)"{}:         */}}
\DoxyCodeLine{00877 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{00878     \textcolor{keywordflow}{if} (hadc-\/>MspDeInitCallback == NULL)}
\DoxyCodeLine{00879     \{}
\DoxyCodeLine{00880       hadc-\/>MspDeInitCallback = HAL\_ADC\_MspDeInit; \textcolor{comment}{/* Legacy weak MspDeInit  */}}
\DoxyCodeLine{00881     \}}
\DoxyCodeLine{00882 }
\DoxyCodeLine{00883     \textcolor{comment}{/* DeInit the low level hardware */}}
\DoxyCodeLine{00884     hadc-\/>MspDeInitCallback(hadc);}
\DoxyCodeLine{00885 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00886     \textcolor{comment}{/* DeInit the low level hardware */}}
\DoxyCodeLine{00887     HAL\_ADC\_MspDeInit(hadc);}
\DoxyCodeLine{00888 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{00889   \}}
\DoxyCodeLine{00890 }
\DoxyCodeLine{00891   \textcolor{comment}{/* Set ADC error code to none */}}
\DoxyCodeLine{00892   ADC\_CLEAR\_ERRORCODE(hadc);}
\DoxyCodeLine{00893 }
\DoxyCodeLine{00894   \textcolor{comment}{/* Reset injected channel configuration parameters */}}
\DoxyCodeLine{00895   hadc-\/>InjectionConfig.ContextQueue = 0;}
\DoxyCodeLine{00896   hadc-\/>InjectionConfig.ChannelCount = 0;}
\DoxyCodeLine{00897 }
\DoxyCodeLine{00898   \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{00899   hadc-\/>State = HAL\_ADC\_STATE\_RESET;}
\DoxyCodeLine{00900 }
\DoxyCodeLine{00901   \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{00902   \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{00903 }
\DoxyCodeLine{00904   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{00905   \textcolor{keywordflow}{return} tmp\_hal\_status;}
\DoxyCodeLine{00906 \}}
\DoxyCodeLine{00907 }
\DoxyCodeLine{00913 \_\_weak \textcolor{keywordtype}{void} HAL\_ADC\_MspInit(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{00914 \{}
\DoxyCodeLine{00915   \textcolor{comment}{/* Prevent unused argument(s) compilation warning */}}
\DoxyCodeLine{00916   UNUSED(hadc);}
\DoxyCodeLine{00917 }
\DoxyCodeLine{00918   \textcolor{comment}{/* NOTE : This function should not be modified. When the callback is needed,}}
\DoxyCodeLine{00919 \textcolor{comment}{            function HAL\_ADC\_MspInit must be implemented in the user file.}}
\DoxyCodeLine{00920 \textcolor{comment}{   */}}
\DoxyCodeLine{00921 \}}
\DoxyCodeLine{00922 }
\DoxyCodeLine{00930 \_\_weak \textcolor{keywordtype}{void} HAL\_ADC\_MspDeInit(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{00931 \{}
\DoxyCodeLine{00932   \textcolor{comment}{/* Prevent unused argument(s) compilation warning */}}
\DoxyCodeLine{00933   UNUSED(hadc);}
\DoxyCodeLine{00934 }
\DoxyCodeLine{00935   \textcolor{comment}{/* NOTE : This function should not be modified. When the callback is needed,}}
\DoxyCodeLine{00936 \textcolor{comment}{            function HAL\_ADC\_MspDeInit must be implemented in the user file.}}
\DoxyCodeLine{00937 \textcolor{comment}{   */}}
\DoxyCodeLine{00938 \}}
\DoxyCodeLine{00939 }
\DoxyCodeLine{00940 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{00964 HAL\_StatusTypeDef HAL\_ADC\_RegisterCallback(ADC\_HandleTypeDef *hadc, HAL\_ADC\_CallbackIDTypeDef CallbackID,}
\DoxyCodeLine{00965                                            pADC\_CallbackTypeDef pCallback)}
\DoxyCodeLine{00966 \{}
\DoxyCodeLine{00967   HAL\_StatusTypeDef status = HAL\_OK;}
\DoxyCodeLine{00968 }
\DoxyCodeLine{00969   \textcolor{keywordflow}{if} (pCallback == NULL)}
\DoxyCodeLine{00970   \{}
\DoxyCodeLine{00971     \textcolor{comment}{/* Update the error code */}}
\DoxyCodeLine{00972     hadc-\/>ErrorCode |= HAL\_ADC\_ERROR\_INVALID\_CALLBACK;}
\DoxyCodeLine{00973 }
\DoxyCodeLine{00974     \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{00975   \}}
\DoxyCodeLine{00976 }
\DoxyCodeLine{00977   \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_READY) != 0UL)}
\DoxyCodeLine{00978   \{}
\DoxyCodeLine{00979     \textcolor{keywordflow}{switch} (CallbackID)}
\DoxyCodeLine{00980     \{}
\DoxyCodeLine{00981       \textcolor{keywordflow}{case} HAL\_ADC\_CONVERSION\_COMPLETE\_CB\_ID :}
\DoxyCodeLine{00982         hadc-\/>ConvCpltCallback = pCallback;}
\DoxyCodeLine{00983         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00984 }
\DoxyCodeLine{00985       \textcolor{keywordflow}{case} HAL\_ADC\_CONVERSION\_HALF\_CB\_ID :}
\DoxyCodeLine{00986         hadc-\/>ConvHalfCpltCallback = pCallback;}
\DoxyCodeLine{00987         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00988 }
\DoxyCodeLine{00989       \textcolor{keywordflow}{case} HAL\_ADC\_LEVEL\_OUT\_OF\_WINDOW\_1\_CB\_ID :}
\DoxyCodeLine{00990         hadc-\/>LevelOutOfWindowCallback = pCallback;}
\DoxyCodeLine{00991         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00992 }
\DoxyCodeLine{00993       \textcolor{keywordflow}{case} HAL\_ADC\_ERROR\_CB\_ID :}
\DoxyCodeLine{00994         hadc-\/>ErrorCallback = pCallback;}
\DoxyCodeLine{00995         \textcolor{keywordflow}{break};}
\DoxyCodeLine{00996 }
\DoxyCodeLine{00997       \textcolor{keywordflow}{case} HAL\_ADC\_INJ\_CONVERSION\_COMPLETE\_CB\_ID :}
\DoxyCodeLine{00998         hadc-\/>InjectedConvCpltCallback = pCallback;}
\DoxyCodeLine{00999         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01000 }
\DoxyCodeLine{01001       \textcolor{keywordflow}{case} HAL\_ADC\_INJ\_QUEUE\_OVEFLOW\_CB\_ID :}
\DoxyCodeLine{01002         hadc-\/>InjectedQueueOverflowCallback = pCallback;}
\DoxyCodeLine{01003         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01004 }
\DoxyCodeLine{01005       \textcolor{keywordflow}{case} HAL\_ADC\_LEVEL\_OUT\_OF\_WINDOW\_2\_CB\_ID :}
\DoxyCodeLine{01006         hadc-\/>LevelOutOfWindow2Callback = pCallback;}
\DoxyCodeLine{01007         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01008 }
\DoxyCodeLine{01009       \textcolor{keywordflow}{case} HAL\_ADC\_LEVEL\_OUT\_OF\_WINDOW\_3\_CB\_ID :}
\DoxyCodeLine{01010         hadc-\/>LevelOutOfWindow3Callback = pCallback;}
\DoxyCodeLine{01011         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01012 }
\DoxyCodeLine{01013       \textcolor{keywordflow}{case} HAL\_ADC\_END\_OF\_SAMPLING\_CB\_ID :}
\DoxyCodeLine{01014         hadc-\/>EndOfSamplingCallback = pCallback;}
\DoxyCodeLine{01015         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01016 }
\DoxyCodeLine{01017       \textcolor{keywordflow}{case} HAL\_ADC\_MSPINIT\_CB\_ID :}
\DoxyCodeLine{01018         hadc-\/>MspInitCallback = pCallback;}
\DoxyCodeLine{01019         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01020 }
\DoxyCodeLine{01021       \textcolor{keywordflow}{case} HAL\_ADC\_MSPDEINIT\_CB\_ID :}
\DoxyCodeLine{01022         hadc-\/>MspDeInitCallback = pCallback;}
\DoxyCodeLine{01023         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01024 }
\DoxyCodeLine{01025       default :}
\DoxyCodeLine{01026         \textcolor{comment}{/* Update the error code */}}
\DoxyCodeLine{01027         hadc-\/>ErrorCode |= HAL\_ADC\_ERROR\_INVALID\_CALLBACK;}
\DoxyCodeLine{01028 }
\DoxyCodeLine{01029         \textcolor{comment}{/* Return error status */}}
\DoxyCodeLine{01030         status = HAL\_ERROR;}
\DoxyCodeLine{01031         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01032     \}}
\DoxyCodeLine{01033   \}}
\DoxyCodeLine{01034   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (HAL\_ADC\_STATE\_RESET == hadc-\/>State)}
\DoxyCodeLine{01035   \{}
\DoxyCodeLine{01036     \textcolor{keywordflow}{switch} (CallbackID)}
\DoxyCodeLine{01037     \{}
\DoxyCodeLine{01038       \textcolor{keywordflow}{case} HAL\_ADC\_MSPINIT\_CB\_ID :}
\DoxyCodeLine{01039         hadc-\/>MspInitCallback = pCallback;}
\DoxyCodeLine{01040         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01041 }
\DoxyCodeLine{01042       \textcolor{keywordflow}{case} HAL\_ADC\_MSPDEINIT\_CB\_ID :}
\DoxyCodeLine{01043         hadc-\/>MspDeInitCallback = pCallback;}
\DoxyCodeLine{01044         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01045 }
\DoxyCodeLine{01046       default :}
\DoxyCodeLine{01047         \textcolor{comment}{/* Update the error code */}}
\DoxyCodeLine{01048         hadc-\/>ErrorCode |= HAL\_ADC\_ERROR\_INVALID\_CALLBACK;}
\DoxyCodeLine{01049 }
\DoxyCodeLine{01050         \textcolor{comment}{/* Return error status */}}
\DoxyCodeLine{01051         status = HAL\_ERROR;}
\DoxyCodeLine{01052         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01053     \}}
\DoxyCodeLine{01054   \}}
\DoxyCodeLine{01055   \textcolor{keywordflow}{else}}
\DoxyCodeLine{01056   \{}
\DoxyCodeLine{01057     \textcolor{comment}{/* Update the error code */}}
\DoxyCodeLine{01058     hadc-\/>ErrorCode |= HAL\_ADC\_ERROR\_INVALID\_CALLBACK;}
\DoxyCodeLine{01059 }
\DoxyCodeLine{01060     \textcolor{comment}{/* Return error status */}}
\DoxyCodeLine{01061     status =  HAL\_ERROR;}
\DoxyCodeLine{01062   \}}
\DoxyCodeLine{01063 }
\DoxyCodeLine{01064   \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{01065 \}}
\DoxyCodeLine{01066 }
\DoxyCodeLine{01089 HAL\_StatusTypeDef HAL\_ADC\_UnRegisterCallback(ADC\_HandleTypeDef *hadc, HAL\_ADC\_CallbackIDTypeDef CallbackID)}
\DoxyCodeLine{01090 \{}
\DoxyCodeLine{01091   HAL\_StatusTypeDef status = HAL\_OK;}
\DoxyCodeLine{01092 }
\DoxyCodeLine{01093   \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_READY) != 0UL)}
\DoxyCodeLine{01094   \{}
\DoxyCodeLine{01095     \textcolor{keywordflow}{switch} (CallbackID)}
\DoxyCodeLine{01096     \{}
\DoxyCodeLine{01097       \textcolor{keywordflow}{case} HAL\_ADC\_CONVERSION\_COMPLETE\_CB\_ID :}
\DoxyCodeLine{01098         hadc-\/>ConvCpltCallback = HAL\_ADC\_ConvCpltCallback;}
\DoxyCodeLine{01099         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01100 }
\DoxyCodeLine{01101       \textcolor{keywordflow}{case} HAL\_ADC\_CONVERSION\_HALF\_CB\_ID :}
\DoxyCodeLine{01102         hadc-\/>ConvHalfCpltCallback = HAL\_ADC\_ConvHalfCpltCallback;}
\DoxyCodeLine{01103         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01104 }
\DoxyCodeLine{01105       \textcolor{keywordflow}{case} HAL\_ADC\_LEVEL\_OUT\_OF\_WINDOW\_1\_CB\_ID :}
\DoxyCodeLine{01106         hadc-\/>LevelOutOfWindowCallback = HAL\_ADC\_LevelOutOfWindowCallback;}
\DoxyCodeLine{01107         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01108 }
\DoxyCodeLine{01109       \textcolor{keywordflow}{case} HAL\_ADC\_ERROR\_CB\_ID :}
\DoxyCodeLine{01110         hadc-\/>ErrorCallback = HAL\_ADC\_ErrorCallback;}
\DoxyCodeLine{01111         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01112 }
\DoxyCodeLine{01113       \textcolor{keywordflow}{case} HAL\_ADC\_INJ\_CONVERSION\_COMPLETE\_CB\_ID :}
\DoxyCodeLine{01114         hadc-\/>InjectedConvCpltCallback = HAL\_ADCEx\_InjectedConvCpltCallback;}
\DoxyCodeLine{01115         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01116 }
\DoxyCodeLine{01117       \textcolor{keywordflow}{case} HAL\_ADC\_INJ\_QUEUE\_OVEFLOW\_CB\_ID :}
\DoxyCodeLine{01118         hadc-\/>InjectedQueueOverflowCallback = HAL\_ADCEx\_InjectedQueueOverflowCallback;}
\DoxyCodeLine{01119         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01120 }
\DoxyCodeLine{01121       \textcolor{keywordflow}{case} HAL\_ADC\_LEVEL\_OUT\_OF\_WINDOW\_2\_CB\_ID :}
\DoxyCodeLine{01122         hadc-\/>LevelOutOfWindow2Callback = HAL\_ADCEx\_LevelOutOfWindow2Callback;}
\DoxyCodeLine{01123         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01124 }
\DoxyCodeLine{01125       \textcolor{keywordflow}{case} HAL\_ADC\_LEVEL\_OUT\_OF\_WINDOW\_3\_CB\_ID :}
\DoxyCodeLine{01126         hadc-\/>LevelOutOfWindow3Callback = HAL\_ADCEx\_LevelOutOfWindow3Callback;}
\DoxyCodeLine{01127         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01128 }
\DoxyCodeLine{01129       \textcolor{keywordflow}{case} HAL\_ADC\_END\_OF\_SAMPLING\_CB\_ID :}
\DoxyCodeLine{01130         hadc-\/>EndOfSamplingCallback = HAL\_ADCEx\_EndOfSamplingCallback;}
\DoxyCodeLine{01131         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01132 }
\DoxyCodeLine{01133       \textcolor{keywordflow}{case} HAL\_ADC\_MSPINIT\_CB\_ID :}
\DoxyCodeLine{01134         hadc-\/>MspInitCallback = HAL\_ADC\_MspInit; \textcolor{comment}{/* Legacy weak MspInit              */}}
\DoxyCodeLine{01135         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01136 }
\DoxyCodeLine{01137       \textcolor{keywordflow}{case} HAL\_ADC\_MSPDEINIT\_CB\_ID :}
\DoxyCodeLine{01138         hadc-\/>MspDeInitCallback = HAL\_ADC\_MspDeInit; \textcolor{comment}{/* Legacy weak MspDeInit            */}}
\DoxyCodeLine{01139         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01140 }
\DoxyCodeLine{01141       default :}
\DoxyCodeLine{01142         \textcolor{comment}{/* Update the error code */}}
\DoxyCodeLine{01143         hadc-\/>ErrorCode |= HAL\_ADC\_ERROR\_INVALID\_CALLBACK;}
\DoxyCodeLine{01144 }
\DoxyCodeLine{01145         \textcolor{comment}{/* Return error status */}}
\DoxyCodeLine{01146         status =  HAL\_ERROR;}
\DoxyCodeLine{01147         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01148     \}}
\DoxyCodeLine{01149   \}}
\DoxyCodeLine{01150   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (HAL\_ADC\_STATE\_RESET == hadc-\/>State)}
\DoxyCodeLine{01151   \{}
\DoxyCodeLine{01152     \textcolor{keywordflow}{switch} (CallbackID)}
\DoxyCodeLine{01153     \{}
\DoxyCodeLine{01154       \textcolor{keywordflow}{case} HAL\_ADC\_MSPINIT\_CB\_ID :}
\DoxyCodeLine{01155         hadc-\/>MspInitCallback = HAL\_ADC\_MspInit;                   \textcolor{comment}{/* Legacy weak MspInit              */}}
\DoxyCodeLine{01156         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01157 }
\DoxyCodeLine{01158       \textcolor{keywordflow}{case} HAL\_ADC\_MSPDEINIT\_CB\_ID :}
\DoxyCodeLine{01159         hadc-\/>MspDeInitCallback = HAL\_ADC\_MspDeInit;               \textcolor{comment}{/* Legacy weak MspDeInit            */}}
\DoxyCodeLine{01160         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01161 }
\DoxyCodeLine{01162       default :}
\DoxyCodeLine{01163         \textcolor{comment}{/* Update the error code */}}
\DoxyCodeLine{01164         hadc-\/>ErrorCode |= HAL\_ADC\_ERROR\_INVALID\_CALLBACK;}
\DoxyCodeLine{01165 }
\DoxyCodeLine{01166         \textcolor{comment}{/* Return error status */}}
\DoxyCodeLine{01167         status =  HAL\_ERROR;}
\DoxyCodeLine{01168         \textcolor{keywordflow}{break};}
\DoxyCodeLine{01169     \}}
\DoxyCodeLine{01170   \}}
\DoxyCodeLine{01171   \textcolor{keywordflow}{else}}
\DoxyCodeLine{01172   \{}
\DoxyCodeLine{01173     \textcolor{comment}{/* Update the error code */}}
\DoxyCodeLine{01174     hadc-\/>ErrorCode |= HAL\_ADC\_ERROR\_INVALID\_CALLBACK;}
\DoxyCodeLine{01175 }
\DoxyCodeLine{01176     \textcolor{comment}{/* Return error status */}}
\DoxyCodeLine{01177     status =  HAL\_ERROR;}
\DoxyCodeLine{01178   \}}
\DoxyCodeLine{01179 }
\DoxyCodeLine{01180   \textcolor{keywordflow}{return} status;}
\DoxyCodeLine{01181 \}}
\DoxyCodeLine{01182 }
\DoxyCodeLine{01183 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{01184 }
\DoxyCodeLine{01220 HAL\_StatusTypeDef HAL\_ADC\_Start(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{01221 \{}
\DoxyCodeLine{01222   HAL\_StatusTypeDef tmp\_hal\_status;}
\DoxyCodeLine{01223 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{01224   \textcolor{keyword}{const} ADC\_TypeDef *tmpADC\_Master;}
\DoxyCodeLine{01225   uint32\_t tmp\_multimode\_config = LL\_ADC\_GetMultimode(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{01226 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01227 }
\DoxyCodeLine{01228   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{01229   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{01230 }
\DoxyCodeLine{01231   \textcolor{comment}{/* Perform ADC enable and conversion start if no conversion is on going */}}
\DoxyCodeLine{01232   \textcolor{keywordflow}{if} (LL\_ADC\_REG\_IsConversionOngoing(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{01233   \{}
\DoxyCodeLine{01234     \textcolor{comment}{/* Process locked */}}
\DoxyCodeLine{01235     \_\_HAL\_LOCK(hadc);}
\DoxyCodeLine{01236 }
\DoxyCodeLine{01237     \textcolor{comment}{/* Enable the ADC peripheral */}}
\DoxyCodeLine{01238     tmp\_hal\_status = ADC\_Enable(hadc);}
\DoxyCodeLine{01239 }
\DoxyCodeLine{01240     \textcolor{comment}{/* Start conversion if ADC is effectively enabled */}}
\DoxyCodeLine{01241     \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{01242     \{}
\DoxyCodeLine{01243       \textcolor{comment}{/* Set ADC state                                                        */}}
\DoxyCodeLine{01244       \textcolor{comment}{/* -\/ Clear state bitfield related to regular group conversion results   */}}
\DoxyCodeLine{01245       \textcolor{comment}{/* -\/ Set state bitfield related to regular operation                    */}}
\DoxyCodeLine{01246       ADC\_STATE\_CLR\_SET(hadc-\/>State,}
\DoxyCodeLine{01247                         HAL\_ADC\_STATE\_READY | HAL\_ADC\_STATE\_REG\_EOC | HAL\_ADC\_STATE\_REG\_OVR | HAL\_ADC\_STATE\_REG\_EOSMP,}
\DoxyCodeLine{01248                         HAL\_ADC\_STATE\_REG\_BUSY);}
\DoxyCodeLine{01249 }
\DoxyCodeLine{01250 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{01251       \textcolor{comment}{/* Reset HAL\_ADC\_STATE\_MULTIMODE\_SLAVE bit}}
\DoxyCodeLine{01252 \textcolor{comment}{        -\/ if ADC instance is master or if multimode feature is not available}}
\DoxyCodeLine{01253 \textcolor{comment}{        -\/ if multimode setting is disabled (ADC instance slave in independent mode) */}}
\DoxyCodeLine{01254       \textcolor{keywordflow}{if} ((\_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance) == hadc-\/>Instance)}
\DoxyCodeLine{01255           || (tmp\_multimode\_config == LL\_ADC\_MULTI\_INDEPENDENT)}
\DoxyCodeLine{01256          )}
\DoxyCodeLine{01257       \{}
\DoxyCodeLine{01258         CLEAR\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_MULTIMODE\_SLAVE);}
\DoxyCodeLine{01259       \}}
\DoxyCodeLine{01260 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01261 }
\DoxyCodeLine{01262       \textcolor{comment}{/* Set ADC error code */}}
\DoxyCodeLine{01263       \textcolor{comment}{/* Check if a conversion is on going on ADC group injected */}}
\DoxyCodeLine{01264       \textcolor{keywordflow}{if} (HAL\_IS\_BIT\_SET(hadc-\/>State, HAL\_ADC\_STATE\_INJ\_BUSY))}
\DoxyCodeLine{01265       \{}
\DoxyCodeLine{01266         \textcolor{comment}{/* Reset ADC error code fields related to regular conversions only */}}
\DoxyCodeLine{01267         CLEAR\_BIT(hadc-\/>ErrorCode, (HAL\_ADC\_ERROR\_OVR | HAL\_ADC\_ERROR\_DMA));}
\DoxyCodeLine{01268       \}}
\DoxyCodeLine{01269       \textcolor{keywordflow}{else}}
\DoxyCodeLine{01270       \{}
\DoxyCodeLine{01271         \textcolor{comment}{/* Reset all ADC error code fields */}}
\DoxyCodeLine{01272         ADC\_CLEAR\_ERRORCODE(hadc);}
\DoxyCodeLine{01273       \}}
\DoxyCodeLine{01274 }
\DoxyCodeLine{01275       \textcolor{comment}{/* Clear ADC group regular conversion flag and overrun flag               */}}
\DoxyCodeLine{01276       \textcolor{comment}{/* (To ensure of no unknown state from potential previous ADC operations) */}}
\DoxyCodeLine{01277       \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, (ADC\_FLAG\_EOC | ADC\_FLAG\_EOS | ADC\_FLAG\_OVR));}
\DoxyCodeLine{01278 }
\DoxyCodeLine{01279       \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{01280       \textcolor{comment}{/* Unlock before starting ADC conversions: in case of potential         */}}
\DoxyCodeLine{01281       \textcolor{comment}{/* interruption, to let the process to ADC IRQ Handler.                 */}}
\DoxyCodeLine{01282       \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{01283 }
\DoxyCodeLine{01284       \textcolor{comment}{/* Enable conversion of regular group.                                  */}}
\DoxyCodeLine{01285       \textcolor{comment}{/* If software start has been selected, conversion starts immediately.  */}}
\DoxyCodeLine{01286       \textcolor{comment}{/* If external trigger has been selected, conversion will start at next */}}
\DoxyCodeLine{01287       \textcolor{comment}{/* trigger event.                                                       */}}
\DoxyCodeLine{01288       \textcolor{comment}{/* Case of multimode enabled (when multimode feature is available):     */}}
\DoxyCodeLine{01289       \textcolor{comment}{/*  -\/ if ADC is slave and dual regular conversions are enabled, ADC is  */}}
\DoxyCodeLine{01290       \textcolor{comment}{/*    enabled only (conversion is not started),                         */}}
\DoxyCodeLine{01291       \textcolor{comment}{/*  -\/ if ADC is master, ADC is enabled and conversion is started.       */}}
\DoxyCodeLine{01292 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{01293       \textcolor{keywordflow}{if} ((\_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance) == hadc-\/>Instance)}
\DoxyCodeLine{01294           || (tmp\_multimode\_config == LL\_ADC\_MULTI\_INDEPENDENT)}
\DoxyCodeLine{01295           || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_SIMULT)}
\DoxyCodeLine{01296           || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_ALTERN)}
\DoxyCodeLine{01297          )}
\DoxyCodeLine{01298       \{}
\DoxyCodeLine{01299         \textcolor{comment}{/* ADC instance is not a multimode slave instance with multimode regular conversions enabled */}}
\DoxyCodeLine{01300         \textcolor{keywordflow}{if} (READ\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_JAUTO) != 0UL)}
\DoxyCodeLine{01301         \{}
\DoxyCodeLine{01302           ADC\_STATE\_CLR\_SET(hadc-\/>State, HAL\_ADC\_STATE\_INJ\_EOC, HAL\_ADC\_STATE\_INJ\_BUSY);}
\DoxyCodeLine{01303         \}}
\DoxyCodeLine{01304 }
\DoxyCodeLine{01305         \textcolor{comment}{/* Start ADC group regular conversion */}}
\DoxyCodeLine{01306         LL\_ADC\_REG\_StartConversion(hadc-\/>Instance);}
\DoxyCodeLine{01307       \}}
\DoxyCodeLine{01308       \textcolor{keywordflow}{else}}
\DoxyCodeLine{01309       \{}
\DoxyCodeLine{01310         \textcolor{comment}{/* ADC instance is a multimode slave instance with multimode regular conversions enabled */}}
\DoxyCodeLine{01311         SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_MULTIMODE\_SLAVE);}
\DoxyCodeLine{01312         \textcolor{comment}{/* if Master ADC JAUTO bit is set, update Slave State in setting}}
\DoxyCodeLine{01313 \textcolor{comment}{           HAL\_ADC\_STATE\_INJ\_BUSY bit and in resetting HAL\_ADC\_STATE\_INJ\_EOC bit */}}
\DoxyCodeLine{01314         tmpADC\_Master = \_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance);}
\DoxyCodeLine{01315         \textcolor{keywordflow}{if} (READ\_BIT(tmpADC\_Master-\/>CFGR, ADC\_CFGR\_JAUTO) != 0UL)}
\DoxyCodeLine{01316         \{}
\DoxyCodeLine{01317           ADC\_STATE\_CLR\_SET(hadc-\/>State, HAL\_ADC\_STATE\_INJ\_EOC, HAL\_ADC\_STATE\_INJ\_BUSY);}
\DoxyCodeLine{01318         \}}
\DoxyCodeLine{01319 }
\DoxyCodeLine{01320       \}}
\DoxyCodeLine{01321 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{01322       \textcolor{keywordflow}{if} (READ\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_JAUTO) != 0UL)}
\DoxyCodeLine{01323       \{}
\DoxyCodeLine{01324         ADC\_STATE\_CLR\_SET(hadc-\/>State, HAL\_ADC\_STATE\_INJ\_EOC, HAL\_ADC\_STATE\_INJ\_BUSY);}
\DoxyCodeLine{01325       \}}
\DoxyCodeLine{01326 }
\DoxyCodeLine{01327       \textcolor{comment}{/* Start ADC group regular conversion */}}
\DoxyCodeLine{01328       LL\_ADC\_REG\_StartConversion(hadc-\/>Instance);}
\DoxyCodeLine{01329 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01330     \}}
\DoxyCodeLine{01331     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01332     \{}
\DoxyCodeLine{01333       \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{01334       \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{01335     \}}
\DoxyCodeLine{01336   \}}
\DoxyCodeLine{01337   \textcolor{keywordflow}{else}}
\DoxyCodeLine{01338   \{}
\DoxyCodeLine{01339     tmp\_hal\_status = HAL\_BUSY;}
\DoxyCodeLine{01340   \}}
\DoxyCodeLine{01341 }
\DoxyCodeLine{01342   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{01343   \textcolor{keywordflow}{return} tmp\_hal\_status;}
\DoxyCodeLine{01344 \}}
\DoxyCodeLine{01345 }
\DoxyCodeLine{01355 HAL\_StatusTypeDef HAL\_ADC\_Stop(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{01356 \{}
\DoxyCodeLine{01357   HAL\_StatusTypeDef tmp\_hal\_status;}
\DoxyCodeLine{01358 }
\DoxyCodeLine{01359   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{01360   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{01361 }
\DoxyCodeLine{01362   \textcolor{comment}{/* Process locked */}}
\DoxyCodeLine{01363   \_\_HAL\_LOCK(hadc);}
\DoxyCodeLine{01364 }
\DoxyCodeLine{01365   \textcolor{comment}{/* 1. Stop potential conversion on going, on ADC groups regular and injected */}}
\DoxyCodeLine{01366   tmp\_hal\_status = ADC\_ConversionStop(hadc, ADC\_REGULAR\_INJECTED\_GROUP);}
\DoxyCodeLine{01367 }
\DoxyCodeLine{01368   \textcolor{comment}{/* Disable ADC peripheral if conversions are effectively stopped */}}
\DoxyCodeLine{01369   \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{01370   \{}
\DoxyCodeLine{01371     \textcolor{comment}{/* 2. Disable the ADC peripheral */}}
\DoxyCodeLine{01372     tmp\_hal\_status = ADC\_Disable(hadc);}
\DoxyCodeLine{01373 }
\DoxyCodeLine{01374     \textcolor{comment}{/* Check if ADC is effectively disabled */}}
\DoxyCodeLine{01375     \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{01376     \{}
\DoxyCodeLine{01377       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{01378       ADC\_STATE\_CLR\_SET(hadc-\/>State,}
\DoxyCodeLine{01379                         HAL\_ADC\_STATE\_REG\_BUSY | HAL\_ADC\_STATE\_INJ\_BUSY,}
\DoxyCodeLine{01380                         HAL\_ADC\_STATE\_READY);}
\DoxyCodeLine{01381     \}}
\DoxyCodeLine{01382   \}}
\DoxyCodeLine{01383 }
\DoxyCodeLine{01384   \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{01385   \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{01386 }
\DoxyCodeLine{01387   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{01388   \textcolor{keywordflow}{return} tmp\_hal\_status;}
\DoxyCodeLine{01389 \}}
\DoxyCodeLine{01390 }
\DoxyCodeLine{01409 HAL\_StatusTypeDef HAL\_ADC\_PollForConversion(ADC\_HandleTypeDef *hadc, uint32\_t Timeout)}
\DoxyCodeLine{01410 \{}
\DoxyCodeLine{01411   uint32\_t tickstart;}
\DoxyCodeLine{01412   uint32\_t tmp\_Flag\_End;}
\DoxyCodeLine{01413   uint32\_t tmp\_cfgr;}
\DoxyCodeLine{01414 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{01415   \textcolor{keyword}{const} ADC\_TypeDef *tmpADC\_Master;}
\DoxyCodeLine{01416   uint32\_t tmp\_multimode\_config = LL\_ADC\_GetMultimode(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{01417 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01418 }
\DoxyCodeLine{01419   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{01420   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{01421 }
\DoxyCodeLine{01422   \textcolor{comment}{/* If end of conversion selected to end of sequence conversions */}}
\DoxyCodeLine{01423   \textcolor{keywordflow}{if} (hadc-\/>Init.EOCSelection == ADC\_EOC\_SEQ\_CONV)}
\DoxyCodeLine{01424   \{}
\DoxyCodeLine{01425     tmp\_Flag\_End = ADC\_FLAG\_EOS;}
\DoxyCodeLine{01426   \}}
\DoxyCodeLine{01427   \textcolor{comment}{/* If end of conversion selected to end of unitary conversion */}}
\DoxyCodeLine{01428   \textcolor{keywordflow}{else} \textcolor{comment}{/* ADC\_EOC\_SINGLE\_CONV */}}
\DoxyCodeLine{01429   \{}
\DoxyCodeLine{01430     \textcolor{comment}{/* Verification that ADC configuration is compliant with polling for      */}}
\DoxyCodeLine{01431     \textcolor{comment}{/* each conversion:                                                       */}}
\DoxyCodeLine{01432     \textcolor{comment}{/* Particular case is ADC configured in DMA mode and ADC sequencer with   */}}
\DoxyCodeLine{01433     \textcolor{comment}{/* several ranks and polling for end of each conversion.                  */}}
\DoxyCodeLine{01434     \textcolor{comment}{/* For code simplicity sake, this particular case is generalized to       */}}
\DoxyCodeLine{01435     \textcolor{comment}{/* ADC configured in DMA mode and and polling for end of each conversion. */}}
\DoxyCodeLine{01436 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{01437     \textcolor{keywordflow}{if} ((tmp\_multimode\_config == LL\_ADC\_MULTI\_INDEPENDENT)}
\DoxyCodeLine{01438         || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_SIMULT)}
\DoxyCodeLine{01439         || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_ALTERN)}
\DoxyCodeLine{01440        )}
\DoxyCodeLine{01441     \{}
\DoxyCodeLine{01442       \textcolor{comment}{/* Check ADC DMA mode in independent mode on ADC group regular */}}
\DoxyCodeLine{01443       \textcolor{keywordflow}{if} (READ\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_DMAEN) != 0UL)}
\DoxyCodeLine{01444       \{}
\DoxyCodeLine{01445         SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_CONFIG);}
\DoxyCodeLine{01446         \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{01447       \}}
\DoxyCodeLine{01448       \textcolor{keywordflow}{else}}
\DoxyCodeLine{01449       \{}
\DoxyCodeLine{01450         tmp\_Flag\_End = (ADC\_FLAG\_EOC);}
\DoxyCodeLine{01451       \}}
\DoxyCodeLine{01452     \}}
\DoxyCodeLine{01453     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01454     \{}
\DoxyCodeLine{01455       \textcolor{comment}{/* Check ADC DMA mode in multimode on ADC group regular */}}
\DoxyCodeLine{01456       \textcolor{keywordflow}{if} (LL\_ADC\_GetMultiDMATransfer(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance)) != LL\_ADC\_MULTI\_REG\_DMA\_EACH\_ADC)}
\DoxyCodeLine{01457       \{}
\DoxyCodeLine{01458         SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_CONFIG);}
\DoxyCodeLine{01459         \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{01460       \}}
\DoxyCodeLine{01461       \textcolor{keywordflow}{else}}
\DoxyCodeLine{01462       \{}
\DoxyCodeLine{01463         tmp\_Flag\_End = (ADC\_FLAG\_EOC);}
\DoxyCodeLine{01464       \}}
\DoxyCodeLine{01465     \}}
\DoxyCodeLine{01466 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{01467     \textcolor{comment}{/* Check ADC DMA mode */}}
\DoxyCodeLine{01468     \textcolor{keywordflow}{if} (READ\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_DMAEN) != 0UL)}
\DoxyCodeLine{01469     \{}
\DoxyCodeLine{01470       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_CONFIG);}
\DoxyCodeLine{01471       \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{01472     \}}
\DoxyCodeLine{01473     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01474     \{}
\DoxyCodeLine{01475       tmp\_Flag\_End = (ADC\_FLAG\_EOC);}
\DoxyCodeLine{01476     \}}
\DoxyCodeLine{01477 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01478   \}}
\DoxyCodeLine{01479 }
\DoxyCodeLine{01480   \textcolor{comment}{/* Get tick count */}}
\DoxyCodeLine{01481   tickstart = HAL\_GetTick();}
\DoxyCodeLine{01482 }
\DoxyCodeLine{01483   \textcolor{comment}{/* Wait until End of unitary conversion or sequence conversions flag is raised */}}
\DoxyCodeLine{01484   \textcolor{keywordflow}{while} ((hadc-\/>Instance-\/>ISR \& tmp\_Flag\_End) == 0UL)}
\DoxyCodeLine{01485   \{}
\DoxyCodeLine{01486     \textcolor{comment}{/* Check if timeout is disabled (set to infinite wait) */}}
\DoxyCodeLine{01487     \textcolor{keywordflow}{if} (Timeout != HAL\_MAX\_DELAY)}
\DoxyCodeLine{01488     \{}
\DoxyCodeLine{01489       \textcolor{keywordflow}{if} (((HAL\_GetTick() -\/ tickstart) > Timeout) || (Timeout == 0UL))}
\DoxyCodeLine{01490       \{}
\DoxyCodeLine{01491         \textcolor{comment}{/* New check to avoid false timeout detection in case of preemption */}}
\DoxyCodeLine{01492         \textcolor{keywordflow}{if} ((hadc-\/>Instance-\/>ISR \& tmp\_Flag\_End) == 0UL)}
\DoxyCodeLine{01493         \{}
\DoxyCodeLine{01494           \textcolor{comment}{/* Update ADC state machine to timeout */}}
\DoxyCodeLine{01495           SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_TIMEOUT);}
\DoxyCodeLine{01496 }
\DoxyCodeLine{01497           \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{01498           \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{01499 }
\DoxyCodeLine{01500           \textcolor{keywordflow}{return} HAL\_TIMEOUT;}
\DoxyCodeLine{01501         \}}
\DoxyCodeLine{01502       \}}
\DoxyCodeLine{01503     \}}
\DoxyCodeLine{01504   \}}
\DoxyCodeLine{01505 }
\DoxyCodeLine{01506   \textcolor{comment}{/* Update ADC state machine */}}
\DoxyCodeLine{01507   SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_REG\_EOC);}
\DoxyCodeLine{01508 }
\DoxyCodeLine{01509   \textcolor{comment}{/* Determine whether any further conversion upcoming on group regular       */}}
\DoxyCodeLine{01510   \textcolor{comment}{/* by external trigger, continuous mode or scan sequence on going.          */}}
\DoxyCodeLine{01511   \textcolor{keywordflow}{if} ((LL\_ADC\_REG\_IsTriggerSourceSWStart(hadc-\/>Instance) != 0UL)}
\DoxyCodeLine{01512       \&\& (hadc-\/>Init.ContinuousConvMode == DISABLE)}
\DoxyCodeLine{01513      )}
\DoxyCodeLine{01514   \{}
\DoxyCodeLine{01515     \textcolor{comment}{/* Check whether end of sequence is reached */}}
\DoxyCodeLine{01516     \textcolor{keywordflow}{if} (\_\_HAL\_ADC\_GET\_FLAG(hadc, ADC\_FLAG\_EOS))}
\DoxyCodeLine{01517     \{}
\DoxyCodeLine{01518       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{01519       CLEAR\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_REG\_BUSY);}
\DoxyCodeLine{01520 }
\DoxyCodeLine{01521       \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_INJ\_BUSY) == 0UL)}
\DoxyCodeLine{01522       \{}
\DoxyCodeLine{01523         SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_READY);}
\DoxyCodeLine{01524       \}}
\DoxyCodeLine{01525     \}}
\DoxyCodeLine{01526   \}}
\DoxyCodeLine{01527 }
\DoxyCodeLine{01528   \textcolor{comment}{/* Get relevant register CFGR in ADC instance of ADC master or slave        */}}
\DoxyCodeLine{01529   \textcolor{comment}{/* in function of multimode state (for devices with multimode               */}}
\DoxyCodeLine{01530   \textcolor{comment}{/* available).                                                              */}}
\DoxyCodeLine{01531 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{01532   \textcolor{keywordflow}{if} ((\_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance) == hadc-\/>Instance)}
\DoxyCodeLine{01533       || (tmp\_multimode\_config == LL\_ADC\_MULTI\_INDEPENDENT)}
\DoxyCodeLine{01534       || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_SIMULT)}
\DoxyCodeLine{01535       || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_ALTERN)}
\DoxyCodeLine{01536      )}
\DoxyCodeLine{01537   \{}
\DoxyCodeLine{01538     \textcolor{comment}{/* Retrieve handle ADC CFGR register */}}
\DoxyCodeLine{01539     tmp\_cfgr = READ\_REG(hadc-\/>Instance-\/>CFGR);}
\DoxyCodeLine{01540   \}}
\DoxyCodeLine{01541   \textcolor{keywordflow}{else}}
\DoxyCodeLine{01542   \{}
\DoxyCodeLine{01543     \textcolor{comment}{/* Retrieve Master ADC CFGR register */}}
\DoxyCodeLine{01544     tmpADC\_Master = \_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance);}
\DoxyCodeLine{01545     tmp\_cfgr = READ\_REG(tmpADC\_Master-\/>CFGR);}
\DoxyCodeLine{01546   \}}
\DoxyCodeLine{01547 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{01548   \textcolor{comment}{/* Retrieve handle ADC CFGR register */}}
\DoxyCodeLine{01549   tmp\_cfgr = READ\_REG(hadc-\/>Instance-\/>CFGR);}
\DoxyCodeLine{01550 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01551 }
\DoxyCodeLine{01552   \textcolor{comment}{/* Clear polled flag */}}
\DoxyCodeLine{01553   \textcolor{keywordflow}{if} (tmp\_Flag\_End == ADC\_FLAG\_EOS)}
\DoxyCodeLine{01554   \{}
\DoxyCodeLine{01555     \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_EOS);}
\DoxyCodeLine{01556   \}}
\DoxyCodeLine{01557   \textcolor{keywordflow}{else}}
\DoxyCodeLine{01558   \{}
\DoxyCodeLine{01559     \textcolor{comment}{/* Clear end of conversion EOC flag of regular group if low power feature */}}
\DoxyCodeLine{01560     \textcolor{comment}{/* "{}LowPowerAutoWait "{} is disabled, to not interfere with this feature    */}}
\DoxyCodeLine{01561     \textcolor{comment}{/* until data register is read using function HAL\_ADC\_GetValue().         */}}
\DoxyCodeLine{01562     \textcolor{keywordflow}{if} (READ\_BIT(tmp\_cfgr, ADC\_CFGR\_AUTDLY) == 0UL)}
\DoxyCodeLine{01563     \{}
\DoxyCodeLine{01564       \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, (ADC\_FLAG\_EOC | ADC\_FLAG\_EOS));}
\DoxyCodeLine{01565     \}}
\DoxyCodeLine{01566   \}}
\DoxyCodeLine{01567 }
\DoxyCodeLine{01568   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{01569   \textcolor{keywordflow}{return} HAL\_OK;}
\DoxyCodeLine{01570 \}}
\DoxyCodeLine{01571 }
\DoxyCodeLine{01592 HAL\_StatusTypeDef HAL\_ADC\_PollForEvent(ADC\_HandleTypeDef *hadc, uint32\_t EventType, uint32\_t Timeout)}
\DoxyCodeLine{01593 \{}
\DoxyCodeLine{01594   uint32\_t tickstart;}
\DoxyCodeLine{01595 }
\DoxyCodeLine{01596   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{01597   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{01598   assert\_param(IS\_ADC\_EVENT\_TYPE(EventType));}
\DoxyCodeLine{01599 }
\DoxyCodeLine{01600   \textcolor{comment}{/* Get tick count */}}
\DoxyCodeLine{01601   tickstart = HAL\_GetTick();}
\DoxyCodeLine{01602 }
\DoxyCodeLine{01603   \textcolor{comment}{/* Check selected event flag */}}
\DoxyCodeLine{01604   \textcolor{keywordflow}{while} (\_\_HAL\_ADC\_GET\_FLAG(hadc, EventType) == 0UL)}
\DoxyCodeLine{01605   \{}
\DoxyCodeLine{01606     \textcolor{comment}{/* Check if timeout is disabled (set to infinite wait) */}}
\DoxyCodeLine{01607     \textcolor{keywordflow}{if} (Timeout != HAL\_MAX\_DELAY)}
\DoxyCodeLine{01608     \{}
\DoxyCodeLine{01609       \textcolor{keywordflow}{if} (((HAL\_GetTick() -\/ tickstart) > Timeout) || (Timeout == 0UL))}
\DoxyCodeLine{01610       \{}
\DoxyCodeLine{01611         \textcolor{comment}{/* New check to avoid false timeout detection in case of preemption */}}
\DoxyCodeLine{01612         \textcolor{keywordflow}{if} (\_\_HAL\_ADC\_GET\_FLAG(hadc, EventType) == 0UL)}
\DoxyCodeLine{01613         \{}
\DoxyCodeLine{01614           \textcolor{comment}{/* Update ADC state machine to timeout */}}
\DoxyCodeLine{01615           SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_TIMEOUT);}
\DoxyCodeLine{01616 }
\DoxyCodeLine{01617           \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{01618           \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{01619 }
\DoxyCodeLine{01620           \textcolor{keywordflow}{return} HAL\_TIMEOUT;}
\DoxyCodeLine{01621         \}}
\DoxyCodeLine{01622       \}}
\DoxyCodeLine{01623     \}}
\DoxyCodeLine{01624   \}}
\DoxyCodeLine{01625 }
\DoxyCodeLine{01626   \textcolor{keywordflow}{switch} (EventType)}
\DoxyCodeLine{01627   \{}
\DoxyCodeLine{01628     \textcolor{comment}{/* End Of Sampling event */}}
\DoxyCodeLine{01629     \textcolor{keywordflow}{case} ADC\_EOSMP\_EVENT:}
\DoxyCodeLine{01630       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{01631       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_REG\_EOSMP);}
\DoxyCodeLine{01632 }
\DoxyCodeLine{01633       \textcolor{comment}{/* Clear the End Of Sampling flag */}}
\DoxyCodeLine{01634       \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_EOSMP);}
\DoxyCodeLine{01635 }
\DoxyCodeLine{01636       \textcolor{keywordflow}{break};}
\DoxyCodeLine{01637 }
\DoxyCodeLine{01638     \textcolor{comment}{/* Analog watchdog (level out of window) event */}}
\DoxyCodeLine{01639     \textcolor{comment}{/* Note: In case of several analog watchdog enabled, if needed to know      */}}
\DoxyCodeLine{01640     \textcolor{comment}{/* which one triggered and on which ADCx, test ADC state of analog watchdog */}}
\DoxyCodeLine{01641     \textcolor{comment}{/* flags HAL\_ADC\_STATE\_AWD1/2/3 using function "{}HAL\_ADC\_GetState()"{}.        */}}
\DoxyCodeLine{01642     \textcolor{comment}{/* For example:                                                             */}}
\DoxyCodeLine{01643     \textcolor{comment}{/*  "{} if ((HAL\_ADC\_GetState(hadc1) \& HAL\_ADC\_STATE\_AWD1) != 0UL) "{}          */}}
\DoxyCodeLine{01644     \textcolor{comment}{/*  "{} if ((HAL\_ADC\_GetState(hadc1) \& HAL\_ADC\_STATE\_AWD2) != 0UL) "{}          */}}
\DoxyCodeLine{01645     \textcolor{comment}{/*  "{} if ((HAL\_ADC\_GetState(hadc1) \& HAL\_ADC\_STATE\_AWD3) != 0UL) "{}          */}}
\DoxyCodeLine{01646 }
\DoxyCodeLine{01647     \textcolor{comment}{/* Check analog watchdog 1 flag */}}
\DoxyCodeLine{01648     \textcolor{keywordflow}{case} ADC\_AWD\_EVENT:}
\DoxyCodeLine{01649       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{01650       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_AWD1);}
\DoxyCodeLine{01651 }
\DoxyCodeLine{01652       \textcolor{comment}{/* Clear ADC analog watchdog flag */}}
\DoxyCodeLine{01653       \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_AWD1);}
\DoxyCodeLine{01654 }
\DoxyCodeLine{01655       \textcolor{keywordflow}{break};}
\DoxyCodeLine{01656 }
\DoxyCodeLine{01657     \textcolor{comment}{/* Check analog watchdog 2 flag */}}
\DoxyCodeLine{01658     \textcolor{keywordflow}{case} ADC\_AWD2\_EVENT:}
\DoxyCodeLine{01659       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{01660       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_AWD2);}
\DoxyCodeLine{01661 }
\DoxyCodeLine{01662       \textcolor{comment}{/* Clear ADC analog watchdog flag */}}
\DoxyCodeLine{01663       \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_AWD2);}
\DoxyCodeLine{01664 }
\DoxyCodeLine{01665       \textcolor{keywordflow}{break};}
\DoxyCodeLine{01666 }
\DoxyCodeLine{01667     \textcolor{comment}{/* Check analog watchdog 3 flag */}}
\DoxyCodeLine{01668     \textcolor{keywordflow}{case} ADC\_AWD3\_EVENT:}
\DoxyCodeLine{01669       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{01670       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_AWD3);}
\DoxyCodeLine{01671 }
\DoxyCodeLine{01672       \textcolor{comment}{/* Clear ADC analog watchdog flag */}}
\DoxyCodeLine{01673       \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_AWD3);}
\DoxyCodeLine{01674 }
\DoxyCodeLine{01675       \textcolor{keywordflow}{break};}
\DoxyCodeLine{01676 }
\DoxyCodeLine{01677     \textcolor{comment}{/* Injected context queue overflow event */}}
\DoxyCodeLine{01678     \textcolor{keywordflow}{case} ADC\_JQOVF\_EVENT:}
\DoxyCodeLine{01679       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{01680       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_INJ\_JQOVF);}
\DoxyCodeLine{01681 }
\DoxyCodeLine{01682       \textcolor{comment}{/* Set ADC error code to Injected context queue overflow */}}
\DoxyCodeLine{01683       SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_JQOVF);}
\DoxyCodeLine{01684 }
\DoxyCodeLine{01685       \textcolor{comment}{/* Clear ADC Injected context queue overflow flag */}}
\DoxyCodeLine{01686       \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_JQOVF);}
\DoxyCodeLine{01687 }
\DoxyCodeLine{01688       \textcolor{keywordflow}{break};}
\DoxyCodeLine{01689 }
\DoxyCodeLine{01690     \textcolor{comment}{/* Overrun event */}}
\DoxyCodeLine{01691     \textcolor{keywordflow}{default}: \textcolor{comment}{/* Case ADC\_OVR\_EVENT */}}
\DoxyCodeLine{01692       \textcolor{comment}{/* If overrun is set to overwrite previous data, overrun event is not     */}}
\DoxyCodeLine{01693       \textcolor{comment}{/* considered as an error.                                                */}}
\DoxyCodeLine{01694       \textcolor{comment}{/* (cf ref manual "{}Managing conversions without using the DMA and without */}}
\DoxyCodeLine{01695       \textcolor{comment}{/* overrun "{})                                                             */}}
\DoxyCodeLine{01696       \textcolor{keywordflow}{if} (hadc-\/>Init.Overrun == ADC\_OVR\_DATA\_PRESERVED)}
\DoxyCodeLine{01697       \{}
\DoxyCodeLine{01698         \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{01699         SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_REG\_OVR);}
\DoxyCodeLine{01700 }
\DoxyCodeLine{01701         \textcolor{comment}{/* Set ADC error code to overrun */}}
\DoxyCodeLine{01702         SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_OVR);}
\DoxyCodeLine{01703       \}}
\DoxyCodeLine{01704       \textcolor{keywordflow}{else}}
\DoxyCodeLine{01705       \{}
\DoxyCodeLine{01706         \textcolor{comment}{/* Clear ADC Overrun flag only if Overrun is set to ADC\_OVR\_DATA\_OVERWRITTEN}}
\DoxyCodeLine{01707 \textcolor{comment}{           otherwise, data register is potentially overwritten by new converted data as soon}}
\DoxyCodeLine{01708 \textcolor{comment}{           as OVR is cleared. */}}
\DoxyCodeLine{01709         \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_OVR);}
\DoxyCodeLine{01710       \}}
\DoxyCodeLine{01711       \textcolor{keywordflow}{break};}
\DoxyCodeLine{01712   \}}
\DoxyCodeLine{01713 }
\DoxyCodeLine{01714   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{01715   \textcolor{keywordflow}{return} HAL\_OK;}
\DoxyCodeLine{01716 \}}
\DoxyCodeLine{01717 }
\DoxyCodeLine{01741 HAL\_StatusTypeDef HAL\_ADC\_Start\_IT(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{01742 \{}
\DoxyCodeLine{01743   HAL\_StatusTypeDef tmp\_hal\_status;}
\DoxyCodeLine{01744 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{01745   \textcolor{keyword}{const} ADC\_TypeDef *tmpADC\_Master;}
\DoxyCodeLine{01746   uint32\_t tmp\_multimode\_config = LL\_ADC\_GetMultimode(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{01747 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01748 }
\DoxyCodeLine{01749   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{01750   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{01751 }
\DoxyCodeLine{01752   \textcolor{comment}{/* Perform ADC enable and conversion start if no conversion is on going */}}
\DoxyCodeLine{01753   \textcolor{keywordflow}{if} (LL\_ADC\_REG\_IsConversionOngoing(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{01754   \{}
\DoxyCodeLine{01755     \textcolor{comment}{/* Process locked */}}
\DoxyCodeLine{01756     \_\_HAL\_LOCK(hadc);}
\DoxyCodeLine{01757 }
\DoxyCodeLine{01758     \textcolor{comment}{/* Enable the ADC peripheral */}}
\DoxyCodeLine{01759     tmp\_hal\_status = ADC\_Enable(hadc);}
\DoxyCodeLine{01760 }
\DoxyCodeLine{01761     \textcolor{comment}{/* Start conversion if ADC is effectively enabled */}}
\DoxyCodeLine{01762     \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{01763     \{}
\DoxyCodeLine{01764       \textcolor{comment}{/* Set ADC state                                                        */}}
\DoxyCodeLine{01765       \textcolor{comment}{/* -\/ Clear state bitfield related to regular group conversion results   */}}
\DoxyCodeLine{01766       \textcolor{comment}{/* -\/ Set state bitfield related to regular operation                    */}}
\DoxyCodeLine{01767       ADC\_STATE\_CLR\_SET(hadc-\/>State,}
\DoxyCodeLine{01768                         HAL\_ADC\_STATE\_READY | HAL\_ADC\_STATE\_REG\_EOC | HAL\_ADC\_STATE\_REG\_OVR | HAL\_ADC\_STATE\_REG\_EOSMP,}
\DoxyCodeLine{01769                         HAL\_ADC\_STATE\_REG\_BUSY);}
\DoxyCodeLine{01770 }
\DoxyCodeLine{01771 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{01772       \textcolor{comment}{/* Reset HAL\_ADC\_STATE\_MULTIMODE\_SLAVE bit}}
\DoxyCodeLine{01773 \textcolor{comment}{        -\/ if ADC instance is master or if multimode feature is not available}}
\DoxyCodeLine{01774 \textcolor{comment}{        -\/ if multimode setting is disabled (ADC instance slave in independent mode) */}}
\DoxyCodeLine{01775       \textcolor{keywordflow}{if} ((\_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance) == hadc-\/>Instance)}
\DoxyCodeLine{01776           || (tmp\_multimode\_config == LL\_ADC\_MULTI\_INDEPENDENT)}
\DoxyCodeLine{01777          )}
\DoxyCodeLine{01778       \{}
\DoxyCodeLine{01779         CLEAR\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_MULTIMODE\_SLAVE);}
\DoxyCodeLine{01780       \}}
\DoxyCodeLine{01781 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01782 }
\DoxyCodeLine{01783       \textcolor{comment}{/* Set ADC error code */}}
\DoxyCodeLine{01784       \textcolor{comment}{/* Check if a conversion is on going on ADC group injected */}}
\DoxyCodeLine{01785       \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_INJ\_BUSY) != 0UL)}
\DoxyCodeLine{01786       \{}
\DoxyCodeLine{01787         \textcolor{comment}{/* Reset ADC error code fields related to regular conversions only */}}
\DoxyCodeLine{01788         CLEAR\_BIT(hadc-\/>ErrorCode, (HAL\_ADC\_ERROR\_OVR | HAL\_ADC\_ERROR\_DMA));}
\DoxyCodeLine{01789       \}}
\DoxyCodeLine{01790       \textcolor{keywordflow}{else}}
\DoxyCodeLine{01791       \{}
\DoxyCodeLine{01792         \textcolor{comment}{/* Reset all ADC error code fields */}}
\DoxyCodeLine{01793         ADC\_CLEAR\_ERRORCODE(hadc);}
\DoxyCodeLine{01794       \}}
\DoxyCodeLine{01795 }
\DoxyCodeLine{01796       \textcolor{comment}{/* Clear ADC group regular conversion flag and overrun flag               */}}
\DoxyCodeLine{01797       \textcolor{comment}{/* (To ensure of no unknown state from potential previous ADC operations) */}}
\DoxyCodeLine{01798       \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, (ADC\_FLAG\_EOC | ADC\_FLAG\_EOS | ADC\_FLAG\_OVR));}
\DoxyCodeLine{01799 }
\DoxyCodeLine{01800       \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{01801       \textcolor{comment}{/* Unlock before starting ADC conversions: in case of potential         */}}
\DoxyCodeLine{01802       \textcolor{comment}{/* interruption, to let the process to ADC IRQ Handler.                 */}}
\DoxyCodeLine{01803       \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{01804 }
\DoxyCodeLine{01805       \textcolor{comment}{/* Disable all interruptions before enabling the desired ones */}}
\DoxyCodeLine{01806       \_\_HAL\_ADC\_DISABLE\_IT(hadc, (ADC\_IT\_EOC | ADC\_IT\_EOS | ADC\_IT\_OVR));}
\DoxyCodeLine{01807 }
\DoxyCodeLine{01808       \textcolor{comment}{/* Enable ADC end of conversion interrupt */}}
\DoxyCodeLine{01809       \textcolor{keywordflow}{switch} (hadc-\/>Init.EOCSelection)}
\DoxyCodeLine{01810       \{}
\DoxyCodeLine{01811         \textcolor{keywordflow}{case} ADC\_EOC\_SEQ\_CONV:}
\DoxyCodeLine{01812           \_\_HAL\_ADC\_ENABLE\_IT(hadc, ADC\_IT\_EOS);}
\DoxyCodeLine{01813           \textcolor{keywordflow}{break};}
\DoxyCodeLine{01814         \textcolor{comment}{/* case ADC\_EOC\_SINGLE\_CONV */}}
\DoxyCodeLine{01815         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{01816           \_\_HAL\_ADC\_ENABLE\_IT(hadc, ADC\_IT\_EOC);}
\DoxyCodeLine{01817           \textcolor{keywordflow}{break};}
\DoxyCodeLine{01818       \}}
\DoxyCodeLine{01819 }
\DoxyCodeLine{01820       \textcolor{comment}{/* Enable ADC overrun interrupt */}}
\DoxyCodeLine{01821       \textcolor{comment}{/* If hadc-\/>Init.Overrun is set to ADC\_OVR\_DATA\_PRESERVED, only then is}}
\DoxyCodeLine{01822 \textcolor{comment}{         ADC\_IT\_OVR enabled; otherwise data overwrite is considered as normal}}
\DoxyCodeLine{01823 \textcolor{comment}{         behavior and no CPU time is lost for a non-\/processed interruption */}}
\DoxyCodeLine{01824       \textcolor{keywordflow}{if} (hadc-\/>Init.Overrun == ADC\_OVR\_DATA\_PRESERVED)}
\DoxyCodeLine{01825       \{}
\DoxyCodeLine{01826         \_\_HAL\_ADC\_ENABLE\_IT(hadc, ADC\_IT\_OVR);}
\DoxyCodeLine{01827       \}}
\DoxyCodeLine{01828 }
\DoxyCodeLine{01829       \textcolor{comment}{/* Enable conversion of regular group.                                  */}}
\DoxyCodeLine{01830       \textcolor{comment}{/* If software start has been selected, conversion starts immediately.  */}}
\DoxyCodeLine{01831       \textcolor{comment}{/* If external trigger has been selected, conversion will start at next */}}
\DoxyCodeLine{01832       \textcolor{comment}{/* trigger event.                                                       */}}
\DoxyCodeLine{01833       \textcolor{comment}{/* Case of multimode enabled (when multimode feature is available):     */}}
\DoxyCodeLine{01834       \textcolor{comment}{/*  -\/ if ADC is slave and dual regular conversions are enabled, ADC is  */}}
\DoxyCodeLine{01835       \textcolor{comment}{/*    enabled only (conversion is not started),                         */}}
\DoxyCodeLine{01836       \textcolor{comment}{/*  -\/ if ADC is master, ADC is enabled and conversion is started.       */}}
\DoxyCodeLine{01837 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{01838       \textcolor{keywordflow}{if} ((\_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance) == hadc-\/>Instance)}
\DoxyCodeLine{01839           || (tmp\_multimode\_config == LL\_ADC\_MULTI\_INDEPENDENT)}
\DoxyCodeLine{01840           || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_SIMULT)}
\DoxyCodeLine{01841           || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_ALTERN)}
\DoxyCodeLine{01842          )}
\DoxyCodeLine{01843       \{}
\DoxyCodeLine{01844         \textcolor{comment}{/* ADC instance is not a multimode slave instance with multimode regular conversions enabled */}}
\DoxyCodeLine{01845         \textcolor{keywordflow}{if} (READ\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_JAUTO) != 0UL)}
\DoxyCodeLine{01846         \{}
\DoxyCodeLine{01847           ADC\_STATE\_CLR\_SET(hadc-\/>State, HAL\_ADC\_STATE\_INJ\_EOC, HAL\_ADC\_STATE\_INJ\_BUSY);}
\DoxyCodeLine{01848 }
\DoxyCodeLine{01849           \textcolor{comment}{/* Enable as well injected interruptions in case}}
\DoxyCodeLine{01850 \textcolor{comment}{           HAL\_ADCEx\_InjectedStart\_IT() has not been called beforehand. This}}
\DoxyCodeLine{01851 \textcolor{comment}{           allows to start regular and injected conversions when JAUTO is}}
\DoxyCodeLine{01852 \textcolor{comment}{           set with a single call to HAL\_ADC\_Start\_IT() */}}
\DoxyCodeLine{01853           \textcolor{keywordflow}{switch} (hadc-\/>Init.EOCSelection)}
\DoxyCodeLine{01854           \{}
\DoxyCodeLine{01855             \textcolor{keywordflow}{case} ADC\_EOC\_SEQ\_CONV:}
\DoxyCodeLine{01856               \_\_HAL\_ADC\_DISABLE\_IT(hadc, ADC\_IT\_JEOC);}
\DoxyCodeLine{01857               \_\_HAL\_ADC\_ENABLE\_IT(hadc, ADC\_IT\_JEOS);}
\DoxyCodeLine{01858               \textcolor{keywordflow}{break};}
\DoxyCodeLine{01859             \textcolor{comment}{/* case ADC\_EOC\_SINGLE\_CONV */}}
\DoxyCodeLine{01860             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{01861               \_\_HAL\_ADC\_DISABLE\_IT(hadc, ADC\_IT\_JEOS);}
\DoxyCodeLine{01862               \_\_HAL\_ADC\_ENABLE\_IT(hadc, ADC\_IT\_JEOC);}
\DoxyCodeLine{01863               \textcolor{keywordflow}{break};}
\DoxyCodeLine{01864           \}}
\DoxyCodeLine{01865         \}}
\DoxyCodeLine{01866 }
\DoxyCodeLine{01867         \textcolor{comment}{/* Start ADC group regular conversion */}}
\DoxyCodeLine{01868         LL\_ADC\_REG\_StartConversion(hadc-\/>Instance);}
\DoxyCodeLine{01869       \}}
\DoxyCodeLine{01870       \textcolor{keywordflow}{else}}
\DoxyCodeLine{01871       \{}
\DoxyCodeLine{01872         \textcolor{comment}{/* ADC instance is a multimode slave instance with multimode regular conversions enabled */}}
\DoxyCodeLine{01873         SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_MULTIMODE\_SLAVE);}
\DoxyCodeLine{01874         \textcolor{comment}{/* if Master ADC JAUTO bit is set, Slave injected interruptions}}
\DoxyCodeLine{01875 \textcolor{comment}{           are enabled nevertheless (for same reason as above) */}}
\DoxyCodeLine{01876         tmpADC\_Master = \_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance);}
\DoxyCodeLine{01877         \textcolor{keywordflow}{if} (READ\_BIT(tmpADC\_Master-\/>CFGR, ADC\_CFGR\_JAUTO) != 0UL)}
\DoxyCodeLine{01878         \{}
\DoxyCodeLine{01879           \textcolor{comment}{/* First, update Slave State in setting HAL\_ADC\_STATE\_INJ\_BUSY bit}}
\DoxyCodeLine{01880 \textcolor{comment}{             and in resetting HAL\_ADC\_STATE\_INJ\_EOC bit */}}
\DoxyCodeLine{01881           ADC\_STATE\_CLR\_SET(hadc-\/>State, HAL\_ADC\_STATE\_INJ\_EOC, HAL\_ADC\_STATE\_INJ\_BUSY);}
\DoxyCodeLine{01882           \textcolor{comment}{/* Next, set Slave injected interruptions */}}
\DoxyCodeLine{01883           \textcolor{keywordflow}{switch} (hadc-\/>Init.EOCSelection)}
\DoxyCodeLine{01884           \{}
\DoxyCodeLine{01885             \textcolor{keywordflow}{case} ADC\_EOC\_SEQ\_CONV:}
\DoxyCodeLine{01886               \_\_HAL\_ADC\_DISABLE\_IT(hadc, ADC\_IT\_JEOC);}
\DoxyCodeLine{01887               \_\_HAL\_ADC\_ENABLE\_IT(hadc, ADC\_IT\_JEOS);}
\DoxyCodeLine{01888               \textcolor{keywordflow}{break};}
\DoxyCodeLine{01889             \textcolor{comment}{/* case ADC\_EOC\_SINGLE\_CONV */}}
\DoxyCodeLine{01890             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{01891               \_\_HAL\_ADC\_DISABLE\_IT(hadc, ADC\_IT\_JEOS);}
\DoxyCodeLine{01892               \_\_HAL\_ADC\_ENABLE\_IT(hadc, ADC\_IT\_JEOC);}
\DoxyCodeLine{01893               \textcolor{keywordflow}{break};}
\DoxyCodeLine{01894           \}}
\DoxyCodeLine{01895         \}}
\DoxyCodeLine{01896       \}}
\DoxyCodeLine{01897 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{01898       \textcolor{comment}{/* ADC instance is not a multimode slave instance with multimode regular conversions enabled */}}
\DoxyCodeLine{01899       \textcolor{keywordflow}{if} (READ\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_JAUTO) != 0UL)}
\DoxyCodeLine{01900       \{}
\DoxyCodeLine{01901         ADC\_STATE\_CLR\_SET(hadc-\/>State, HAL\_ADC\_STATE\_INJ\_EOC, HAL\_ADC\_STATE\_INJ\_BUSY);}
\DoxyCodeLine{01902 }
\DoxyCodeLine{01903         \textcolor{comment}{/* Enable as well injected interruptions in case}}
\DoxyCodeLine{01904 \textcolor{comment}{         HAL\_ADCEx\_InjectedStart\_IT() has not been called beforehand. This}}
\DoxyCodeLine{01905 \textcolor{comment}{         allows to start regular and injected conversions when JAUTO is}}
\DoxyCodeLine{01906 \textcolor{comment}{         set with a single call to HAL\_ADC\_Start\_IT() */}}
\DoxyCodeLine{01907         \textcolor{keywordflow}{switch} (hadc-\/>Init.EOCSelection)}
\DoxyCodeLine{01908         \{}
\DoxyCodeLine{01909           \textcolor{keywordflow}{case} ADC\_EOC\_SEQ\_CONV:}
\DoxyCodeLine{01910             \_\_HAL\_ADC\_DISABLE\_IT(hadc, ADC\_IT\_JEOC);}
\DoxyCodeLine{01911             \_\_HAL\_ADC\_ENABLE\_IT(hadc, ADC\_IT\_JEOS);}
\DoxyCodeLine{01912             \textcolor{keywordflow}{break};}
\DoxyCodeLine{01913           \textcolor{comment}{/* case ADC\_EOC\_SINGLE\_CONV */}}
\DoxyCodeLine{01914           \textcolor{keywordflow}{default}:}
\DoxyCodeLine{01915             \_\_HAL\_ADC\_DISABLE\_IT(hadc, ADC\_IT\_JEOS);}
\DoxyCodeLine{01916             \_\_HAL\_ADC\_ENABLE\_IT(hadc, ADC\_IT\_JEOC);}
\DoxyCodeLine{01917             \textcolor{keywordflow}{break};}
\DoxyCodeLine{01918         \}}
\DoxyCodeLine{01919       \}}
\DoxyCodeLine{01920 }
\DoxyCodeLine{01921       \textcolor{comment}{/* Start ADC group regular conversion */}}
\DoxyCodeLine{01922       LL\_ADC\_REG\_StartConversion(hadc-\/>Instance);}
\DoxyCodeLine{01923 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{01924     \}}
\DoxyCodeLine{01925     \textcolor{keywordflow}{else}}
\DoxyCodeLine{01926     \{}
\DoxyCodeLine{01927       \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{01928       \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{01929     \}}
\DoxyCodeLine{01930 }
\DoxyCodeLine{01931   \}}
\DoxyCodeLine{01932   \textcolor{keywordflow}{else}}
\DoxyCodeLine{01933   \{}
\DoxyCodeLine{01934     tmp\_hal\_status = HAL\_BUSY;}
\DoxyCodeLine{01935   \}}
\DoxyCodeLine{01936 }
\DoxyCodeLine{01937   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{01938   \textcolor{keywordflow}{return} tmp\_hal\_status;}
\DoxyCodeLine{01939 \}}
\DoxyCodeLine{01940 }
\DoxyCodeLine{01948 HAL\_StatusTypeDef HAL\_ADC\_Stop\_IT(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{01949 \{}
\DoxyCodeLine{01950   HAL\_StatusTypeDef tmp\_hal\_status;}
\DoxyCodeLine{01951 }
\DoxyCodeLine{01952   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{01953   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{01954 }
\DoxyCodeLine{01955   \textcolor{comment}{/* Process locked */}}
\DoxyCodeLine{01956   \_\_HAL\_LOCK(hadc);}
\DoxyCodeLine{01957 }
\DoxyCodeLine{01958   \textcolor{comment}{/* 1. Stop potential conversion on going, on ADC groups regular and injected */}}
\DoxyCodeLine{01959   tmp\_hal\_status = ADC\_ConversionStop(hadc, ADC\_REGULAR\_INJECTED\_GROUP);}
\DoxyCodeLine{01960 }
\DoxyCodeLine{01961   \textcolor{comment}{/* Disable ADC peripheral if conversions are effectively stopped */}}
\DoxyCodeLine{01962   \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{01963   \{}
\DoxyCodeLine{01964     \textcolor{comment}{/* Disable ADC end of conversion interrupt for regular group */}}
\DoxyCodeLine{01965     \textcolor{comment}{/* Disable ADC overrun interrupt */}}
\DoxyCodeLine{01966     \_\_HAL\_ADC\_DISABLE\_IT(hadc, (ADC\_IT\_EOC | ADC\_IT\_EOS | ADC\_IT\_OVR));}
\DoxyCodeLine{01967 }
\DoxyCodeLine{01968     \textcolor{comment}{/* 2. Disable the ADC peripheral */}}
\DoxyCodeLine{01969     tmp\_hal\_status = ADC\_Disable(hadc);}
\DoxyCodeLine{01970 }
\DoxyCodeLine{01971     \textcolor{comment}{/* Check if ADC is effectively disabled */}}
\DoxyCodeLine{01972     \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{01973     \{}
\DoxyCodeLine{01974       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{01975       ADC\_STATE\_CLR\_SET(hadc-\/>State,}
\DoxyCodeLine{01976                         HAL\_ADC\_STATE\_REG\_BUSY | HAL\_ADC\_STATE\_INJ\_BUSY,}
\DoxyCodeLine{01977                         HAL\_ADC\_STATE\_READY);}
\DoxyCodeLine{01978     \}}
\DoxyCodeLine{01979   \}}
\DoxyCodeLine{01980 }
\DoxyCodeLine{01981   \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{01982   \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{01983 }
\DoxyCodeLine{01984   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{01985   \textcolor{keywordflow}{return} tmp\_hal\_status;}
\DoxyCodeLine{01986 \}}
\DoxyCodeLine{01987 }
\DoxyCodeLine{02001 HAL\_StatusTypeDef HAL\_ADC\_Start\_DMA(ADC\_HandleTypeDef *hadc, uint32\_t *pData, uint32\_t Length)}
\DoxyCodeLine{02002 \{}
\DoxyCodeLine{02003   HAL\_StatusTypeDef tmp\_hal\_status;}
\DoxyCodeLine{02004 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{02005   uint32\_t tmp\_multimode\_config = LL\_ADC\_GetMultimode(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{02006 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02007 }
\DoxyCodeLine{02008   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{02009   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{02010 }
\DoxyCodeLine{02011   \textcolor{comment}{/* Perform ADC enable and conversion start if no conversion is on going */}}
\DoxyCodeLine{02012   \textcolor{keywordflow}{if} (LL\_ADC\_REG\_IsConversionOngoing(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{02013   \{}
\DoxyCodeLine{02014     \textcolor{comment}{/* Process locked */}}
\DoxyCodeLine{02015     \_\_HAL\_LOCK(hadc);}
\DoxyCodeLine{02016 }
\DoxyCodeLine{02017 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{02018     \textcolor{comment}{/* Ensure that multimode regular conversions are not enabled.   */}}
\DoxyCodeLine{02019     \textcolor{comment}{/* Otherwise, dedicated API HAL\_ADCEx\_MultiModeStart\_DMA() must be used.  */}}
\DoxyCodeLine{02020     \textcolor{keywordflow}{if} ((ADC\_IS\_INDEPENDENT(hadc) != RESET)}
\DoxyCodeLine{02021         || (tmp\_multimode\_config == LL\_ADC\_MULTI\_INDEPENDENT)}
\DoxyCodeLine{02022         || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_SIMULT)}
\DoxyCodeLine{02023         || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_ALTERN)}
\DoxyCodeLine{02024        )}
\DoxyCodeLine{02025 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* ADC\_MULTIMODE\_SUPPORT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02026     \{}
\DoxyCodeLine{02027       \textcolor{comment}{/* Enable the ADC peripheral */}}
\DoxyCodeLine{02028       tmp\_hal\_status = ADC\_Enable(hadc);}
\DoxyCodeLine{02029 }
\DoxyCodeLine{02030       \textcolor{comment}{/* Start conversion if ADC is effectively enabled */}}
\DoxyCodeLine{02031       \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{02032       \{}
\DoxyCodeLine{02033         \textcolor{comment}{/* Set ADC state                                                        */}}
\DoxyCodeLine{02034         \textcolor{comment}{/* -\/ Clear state bitfield related to regular group conversion results   */}}
\DoxyCodeLine{02035         \textcolor{comment}{/* -\/ Set state bitfield related to regular operation                    */}}
\DoxyCodeLine{02036         ADC\_STATE\_CLR\_SET(hadc-\/>State,}
\DoxyCodeLine{02037                           HAL\_ADC\_STATE\_READY | HAL\_ADC\_STATE\_REG\_EOC | HAL\_ADC\_STATE\_REG\_OVR | HAL\_ADC\_STATE\_REG\_EOSMP,}
\DoxyCodeLine{02038                           HAL\_ADC\_STATE\_REG\_BUSY);}
\DoxyCodeLine{02039 }
\DoxyCodeLine{02040 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{02041         \textcolor{comment}{/* Reset HAL\_ADC\_STATE\_MULTIMODE\_SLAVE bit}}
\DoxyCodeLine{02042 \textcolor{comment}{          -\/ if ADC instance is master or if multimode feature is not available}}
\DoxyCodeLine{02043 \textcolor{comment}{          -\/ if multimode setting is disabled (ADC instance slave in independent mode) */}}
\DoxyCodeLine{02044         \textcolor{keywordflow}{if} ((\_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance) == hadc-\/>Instance)}
\DoxyCodeLine{02045             || (tmp\_multimode\_config == LL\_ADC\_MULTI\_INDEPENDENT)}
\DoxyCodeLine{02046            )}
\DoxyCodeLine{02047         \{}
\DoxyCodeLine{02048           CLEAR\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_MULTIMODE\_SLAVE);}
\DoxyCodeLine{02049         \}}
\DoxyCodeLine{02050 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02051 }
\DoxyCodeLine{02052         \textcolor{comment}{/* Check if a conversion is on going on ADC group injected */}}
\DoxyCodeLine{02053         \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_INJ\_BUSY) != 0UL)}
\DoxyCodeLine{02054         \{}
\DoxyCodeLine{02055           \textcolor{comment}{/* Reset ADC error code fields related to regular conversions only */}}
\DoxyCodeLine{02056           CLEAR\_BIT(hadc-\/>ErrorCode, (HAL\_ADC\_ERROR\_OVR | HAL\_ADC\_ERROR\_DMA));}
\DoxyCodeLine{02057         \}}
\DoxyCodeLine{02058         \textcolor{keywordflow}{else}}
\DoxyCodeLine{02059         \{}
\DoxyCodeLine{02060           \textcolor{comment}{/* Reset all ADC error code fields */}}
\DoxyCodeLine{02061           ADC\_CLEAR\_ERRORCODE(hadc);}
\DoxyCodeLine{02062         \}}
\DoxyCodeLine{02063 }
\DoxyCodeLine{02064         \textcolor{comment}{/* Set the DMA transfer complete callback */}}
\DoxyCodeLine{02065         hadc-\/>DMA\_Handle-\/>XferCpltCallback = ADC\_DMAConvCplt;}
\DoxyCodeLine{02066 }
\DoxyCodeLine{02067         \textcolor{comment}{/* Set the DMA half transfer complete callback */}}
\DoxyCodeLine{02068         hadc-\/>DMA\_Handle-\/>XferHalfCpltCallback = ADC\_DMAHalfConvCplt;}
\DoxyCodeLine{02069 }
\DoxyCodeLine{02070         \textcolor{comment}{/* Set the DMA error callback */}}
\DoxyCodeLine{02071         hadc-\/>DMA\_Handle-\/>XferErrorCallback = ADC\_DMAError;}
\DoxyCodeLine{02072 }
\DoxyCodeLine{02073 }
\DoxyCodeLine{02074         \textcolor{comment}{/* Manage ADC and DMA start: ADC overrun interruption, DMA start,     */}}
\DoxyCodeLine{02075         \textcolor{comment}{/* ADC start (in case of SW start):                                   */}}
\DoxyCodeLine{02076 }
\DoxyCodeLine{02077         \textcolor{comment}{/* Clear regular group conversion flag and overrun flag               */}}
\DoxyCodeLine{02078         \textcolor{comment}{/* (To ensure of no unknown state from potential previous ADC         */}}
\DoxyCodeLine{02079         \textcolor{comment}{/* operations)                                                        */}}
\DoxyCodeLine{02080         \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, (ADC\_FLAG\_EOC | ADC\_FLAG\_EOS | ADC\_FLAG\_OVR));}
\DoxyCodeLine{02081 }
\DoxyCodeLine{02082         \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{02083         \textcolor{comment}{/* Unlock before starting ADC conversions: in case of potential         */}}
\DoxyCodeLine{02084         \textcolor{comment}{/* interruption, to let the process to ADC IRQ Handler.                 */}}
\DoxyCodeLine{02085         \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{02086 }
\DoxyCodeLine{02087         \textcolor{comment}{/* With DMA, overrun event is always considered as an error even if}}
\DoxyCodeLine{02088 \textcolor{comment}{           hadc-\/>Init.Overrun is set to ADC\_OVR\_DATA\_OVERWRITTEN. Therefore,}}
\DoxyCodeLine{02089 \textcolor{comment}{           ADC\_IT\_OVR is enabled. */}}
\DoxyCodeLine{02090         \_\_HAL\_ADC\_ENABLE\_IT(hadc, ADC\_IT\_OVR);}
\DoxyCodeLine{02091 }
\DoxyCodeLine{02092         \textcolor{comment}{/* Enable ADC DMA mode */}}
\DoxyCodeLine{02093         SET\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_DMAEN);}
\DoxyCodeLine{02094 }
\DoxyCodeLine{02095         \textcolor{comment}{/* Start the DMA channel */}}
\DoxyCodeLine{02096         tmp\_hal\_status = HAL\_DMA\_Start\_IT(hadc-\/>DMA\_Handle, (uint32\_t)\&hadc-\/>Instance-\/>DR, (uint32\_t)pData, Length);}
\DoxyCodeLine{02097 }
\DoxyCodeLine{02098         \textcolor{comment}{/* Enable conversion of regular group.                                  */}}
\DoxyCodeLine{02099         \textcolor{comment}{/* If software start has been selected, conversion starts immediately.  */}}
\DoxyCodeLine{02100         \textcolor{comment}{/* If external trigger has been selected, conversion will start at next */}}
\DoxyCodeLine{02101         \textcolor{comment}{/* trigger event.                                                       */}}
\DoxyCodeLine{02102         \textcolor{comment}{/* Start ADC group regular conversion */}}
\DoxyCodeLine{02103         LL\_ADC\_REG\_StartConversion(hadc-\/>Instance);}
\DoxyCodeLine{02104       \}}
\DoxyCodeLine{02105       \textcolor{keywordflow}{else}}
\DoxyCodeLine{02106       \{}
\DoxyCodeLine{02107         \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{02108         \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{02109       \}}
\DoxyCodeLine{02110 }
\DoxyCodeLine{02111     \}}
\DoxyCodeLine{02112 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{02113     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02114     \{}
\DoxyCodeLine{02115       tmp\_hal\_status = HAL\_ERROR;}
\DoxyCodeLine{02116       \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{02117       \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{02118     \}}
\DoxyCodeLine{02119 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02120   \}}
\DoxyCodeLine{02121   \textcolor{keywordflow}{else}}
\DoxyCodeLine{02122   \{}
\DoxyCodeLine{02123     tmp\_hal\_status = HAL\_BUSY;}
\DoxyCodeLine{02124   \}}
\DoxyCodeLine{02125 }
\DoxyCodeLine{02126   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{02127   \textcolor{keywordflow}{return} tmp\_hal\_status;}
\DoxyCodeLine{02128 \}}
\DoxyCodeLine{02129 }
\DoxyCodeLine{02143 HAL\_StatusTypeDef HAL\_ADC\_Stop\_DMA(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{02144 \{}
\DoxyCodeLine{02145   HAL\_StatusTypeDef tmp\_hal\_status;}
\DoxyCodeLine{02146 }
\DoxyCodeLine{02147   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{02148   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{02149 }
\DoxyCodeLine{02150   \textcolor{comment}{/* Process locked */}}
\DoxyCodeLine{02151   \_\_HAL\_LOCK(hadc);}
\DoxyCodeLine{02152 }
\DoxyCodeLine{02153   \textcolor{comment}{/* 1. Stop potential ADC group regular conversion on going */}}
\DoxyCodeLine{02154   tmp\_hal\_status = ADC\_ConversionStop(hadc, ADC\_REGULAR\_INJECTED\_GROUP);}
\DoxyCodeLine{02155 }
\DoxyCodeLine{02156   \textcolor{comment}{/* Disable ADC peripheral if conversions are effectively stopped */}}
\DoxyCodeLine{02157   \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{02158   \{}
\DoxyCodeLine{02159     \textcolor{comment}{/* Disable ADC DMA (ADC DMA configuration of continuous requests is kept) */}}
\DoxyCodeLine{02160     CLEAR\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_DMAEN);}
\DoxyCodeLine{02161 }
\DoxyCodeLine{02162     \textcolor{comment}{/* Disable the DMA channel (in case of DMA in circular mode or stop       */}}
\DoxyCodeLine{02163     \textcolor{comment}{/* while DMA transfer is on going)                                        */}}
\DoxyCodeLine{02164     \textcolor{keywordflow}{if} (hadc-\/>DMA\_Handle-\/>State == HAL\_DMA\_STATE\_BUSY)}
\DoxyCodeLine{02165     \{}
\DoxyCodeLine{02166       tmp\_hal\_status = HAL\_DMA\_Abort(hadc-\/>DMA\_Handle);}
\DoxyCodeLine{02167 }
\DoxyCodeLine{02168       \textcolor{comment}{/* Check if DMA channel effectively disabled */}}
\DoxyCodeLine{02169       \textcolor{keywordflow}{if} (tmp\_hal\_status != HAL\_OK)}
\DoxyCodeLine{02170       \{}
\DoxyCodeLine{02171         \textcolor{comment}{/* Update ADC state machine to error */}}
\DoxyCodeLine{02172         SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_DMA);}
\DoxyCodeLine{02173       \}}
\DoxyCodeLine{02174     \}}
\DoxyCodeLine{02175 }
\DoxyCodeLine{02176     \textcolor{comment}{/* Disable ADC overrun interrupt */}}
\DoxyCodeLine{02177     \_\_HAL\_ADC\_DISABLE\_IT(hadc, ADC\_IT\_OVR);}
\DoxyCodeLine{02178 }
\DoxyCodeLine{02179     \textcolor{comment}{/* 2. Disable the ADC peripheral */}}
\DoxyCodeLine{02180     \textcolor{comment}{/* Update "{}tmp\_hal\_status"{} only if DMA channel disabling passed,          */}}
\DoxyCodeLine{02181     \textcolor{comment}{/* to keep in memory a potential failing status.                          */}}
\DoxyCodeLine{02182     \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{02183     \{}
\DoxyCodeLine{02184       tmp\_hal\_status = ADC\_Disable(hadc);}
\DoxyCodeLine{02185     \}}
\DoxyCodeLine{02186     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02187     \{}
\DoxyCodeLine{02188       (void)ADC\_Disable(hadc);}
\DoxyCodeLine{02189     \}}
\DoxyCodeLine{02190 }
\DoxyCodeLine{02191     \textcolor{comment}{/* Check if ADC is effectively disabled */}}
\DoxyCodeLine{02192     \textcolor{keywordflow}{if} (tmp\_hal\_status == HAL\_OK)}
\DoxyCodeLine{02193     \{}
\DoxyCodeLine{02194       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{02195       ADC\_STATE\_CLR\_SET(hadc-\/>State,}
\DoxyCodeLine{02196                         HAL\_ADC\_STATE\_REG\_BUSY | HAL\_ADC\_STATE\_INJ\_BUSY,}
\DoxyCodeLine{02197                         HAL\_ADC\_STATE\_READY);}
\DoxyCodeLine{02198     \}}
\DoxyCodeLine{02199 }
\DoxyCodeLine{02200   \}}
\DoxyCodeLine{02201 }
\DoxyCodeLine{02202   \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{02203   \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{02204 }
\DoxyCodeLine{02205   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{02206   \textcolor{keywordflow}{return} tmp\_hal\_status;}
\DoxyCodeLine{02207 \}}
\DoxyCodeLine{02208 }
\DoxyCodeLine{02228 uint32\_t HAL\_ADC\_GetValue(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{02229 \{}
\DoxyCodeLine{02230   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{02231   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{02232 }
\DoxyCodeLine{02233   \textcolor{comment}{/* Note: EOC flag is not cleared here by software because automatically     */}}
\DoxyCodeLine{02234   \textcolor{comment}{/*       cleared by hardware when reading register DR.                      */}}
\DoxyCodeLine{02235 }
\DoxyCodeLine{02236   \textcolor{comment}{/* Return ADC converted value */}}
\DoxyCodeLine{02237   \textcolor{keywordflow}{return} hadc-\/>Instance-\/>DR;}
\DoxyCodeLine{02238 \}}
\DoxyCodeLine{02239 }
\DoxyCodeLine{02249 HAL\_StatusTypeDef HAL\_ADC\_StartSampling(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{02250 \{}
\DoxyCodeLine{02251   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{02252   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{02253 }
\DoxyCodeLine{02254   \textcolor{comment}{/* Start sampling */}}
\DoxyCodeLine{02255   SET\_BIT(hadc-\/>Instance-\/>CFGR2, ADC\_CFGR2\_SWTRIG);}
\DoxyCodeLine{02256 }
\DoxyCodeLine{02257   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{02258   \textcolor{keywordflow}{return} HAL\_OK;}
\DoxyCodeLine{02259 \}}
\DoxyCodeLine{02260 }
\DoxyCodeLine{02271 HAL\_StatusTypeDef HAL\_ADC\_StopSampling(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{02272 \{}
\DoxyCodeLine{02273   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{02274   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{02275 }
\DoxyCodeLine{02276   \textcolor{comment}{/* Start sampling */}}
\DoxyCodeLine{02277   CLEAR\_BIT(hadc-\/>Instance-\/>CFGR2, ADC\_CFGR2\_SWTRIG);}
\DoxyCodeLine{02278 }
\DoxyCodeLine{02279   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{02280   \textcolor{keywordflow}{return} HAL\_OK;}
\DoxyCodeLine{02281 \}}
\DoxyCodeLine{02282 }
\DoxyCodeLine{02288 \textcolor{keywordtype}{void} HAL\_ADC\_IRQHandler(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{02289 \{}
\DoxyCodeLine{02290   uint32\_t overrun\_error = 0UL; \textcolor{comment}{/* flag set if overrun occurrence has to be considered as an error */}}
\DoxyCodeLine{02291   uint32\_t tmp\_isr = hadc-\/>Instance-\/>ISR;}
\DoxyCodeLine{02292   uint32\_t tmp\_ier = hadc-\/>Instance-\/>IER;}
\DoxyCodeLine{02293   uint32\_t tmp\_adc\_inj\_is\_trigger\_source\_sw\_start;}
\DoxyCodeLine{02294   uint32\_t tmp\_adc\_reg\_is\_trigger\_source\_sw\_start;}
\DoxyCodeLine{02295   uint32\_t tmp\_cfgr;}
\DoxyCodeLine{02296 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{02297   \textcolor{keyword}{const} ADC\_TypeDef *tmpADC\_Master;}
\DoxyCodeLine{02298   uint32\_t tmp\_multimode\_config = LL\_ADC\_GetMultimode(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{02299 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02300 }
\DoxyCodeLine{02301   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{02302   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{02303   assert\_param(IS\_ADC\_EOC\_SELECTION(hadc-\/>Init.EOCSelection));}
\DoxyCodeLine{02304 }
\DoxyCodeLine{02305   \textcolor{comment}{/* ========== Check End of Sampling flag for ADC group regular ========== */}}
\DoxyCodeLine{02306   \textcolor{keywordflow}{if} (((tmp\_isr \& ADC\_FLAG\_EOSMP) == ADC\_FLAG\_EOSMP) \&\& ((tmp\_ier \& ADC\_IT\_EOSMP) == ADC\_IT\_EOSMP))}
\DoxyCodeLine{02307   \{}
\DoxyCodeLine{02308     \textcolor{comment}{/* Update state machine on end of sampling status if not in error state */}}
\DoxyCodeLine{02309     \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_ERROR\_INTERNAL) == 0UL)}
\DoxyCodeLine{02310     \{}
\DoxyCodeLine{02311       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{02312       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_REG\_EOSMP);}
\DoxyCodeLine{02313     \}}
\DoxyCodeLine{02314 }
\DoxyCodeLine{02315     \textcolor{comment}{/* End Of Sampling callback */}}
\DoxyCodeLine{02316 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{02317     hadc-\/>EndOfSamplingCallback(hadc);}
\DoxyCodeLine{02318 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{02319     HAL\_ADCEx\_EndOfSamplingCallback(hadc);}
\DoxyCodeLine{02320 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02321 }
\DoxyCodeLine{02322     \textcolor{comment}{/* Clear regular group conversion flag */}}
\DoxyCodeLine{02323     \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_EOSMP);}
\DoxyCodeLine{02324   \}}
\DoxyCodeLine{02325 }
\DoxyCodeLine{02326   \textcolor{comment}{/* ====== Check ADC group regular end of unitary conversion sequence conversions ===== */}}
\DoxyCodeLine{02327   \textcolor{keywordflow}{if} ((((tmp\_isr \& ADC\_FLAG\_EOC) == ADC\_FLAG\_EOC) \&\& ((tmp\_ier \& ADC\_IT\_EOC) == ADC\_IT\_EOC)) ||}
\DoxyCodeLine{02328       (((tmp\_isr \& ADC\_FLAG\_EOS) == ADC\_FLAG\_EOS) \&\& ((tmp\_ier \& ADC\_IT\_EOS) == ADC\_IT\_EOS)))}
\DoxyCodeLine{02329   \{}
\DoxyCodeLine{02330     \textcolor{comment}{/* Update state machine on conversion status if not in error state */}}
\DoxyCodeLine{02331     \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_ERROR\_INTERNAL) == 0UL)}
\DoxyCodeLine{02332     \{}
\DoxyCodeLine{02333       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{02334       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_REG\_EOC);}
\DoxyCodeLine{02335     \}}
\DoxyCodeLine{02336 }
\DoxyCodeLine{02337     \textcolor{comment}{/* Determine whether any further conversion upcoming on group regular     */}}
\DoxyCodeLine{02338     \textcolor{comment}{/* by external trigger, continuous mode or scan sequence on going         */}}
\DoxyCodeLine{02339     \textcolor{comment}{/* to disable interruption.                                               */}}
\DoxyCodeLine{02340     \textcolor{keywordflow}{if} (LL\_ADC\_REG\_IsTriggerSourceSWStart(hadc-\/>Instance) != 0UL)}
\DoxyCodeLine{02341     \{}
\DoxyCodeLine{02342       \textcolor{comment}{/* Get relevant register CFGR in ADC instance of ADC master or slave    */}}
\DoxyCodeLine{02343       \textcolor{comment}{/* in function of multimode state (for devices with multimode           */}}
\DoxyCodeLine{02344       \textcolor{comment}{/* available).                                                          */}}
\DoxyCodeLine{02345 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{02346       \textcolor{keywordflow}{if} ((\_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance) == hadc-\/>Instance)}
\DoxyCodeLine{02347           || (tmp\_multimode\_config == LL\_ADC\_MULTI\_INDEPENDENT)}
\DoxyCodeLine{02348           || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_SIMULT)}
\DoxyCodeLine{02349           || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_INJ\_ALTERN)}
\DoxyCodeLine{02350          )}
\DoxyCodeLine{02351       \{}
\DoxyCodeLine{02352         \textcolor{comment}{/* check CONT bit directly in handle ADC CFGR register */}}
\DoxyCodeLine{02353         tmp\_cfgr = READ\_REG(hadc-\/>Instance-\/>CFGR);}
\DoxyCodeLine{02354       \}}
\DoxyCodeLine{02355       \textcolor{keywordflow}{else}}
\DoxyCodeLine{02356       \{}
\DoxyCodeLine{02357         \textcolor{comment}{/* else need to check Master ADC CONT bit */}}
\DoxyCodeLine{02358         tmpADC\_Master = \_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance);}
\DoxyCodeLine{02359         tmp\_cfgr = READ\_REG(tmpADC\_Master-\/>CFGR);}
\DoxyCodeLine{02360       \}}
\DoxyCodeLine{02361 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{02362       tmp\_cfgr = READ\_REG(hadc-\/>Instance-\/>CFGR);}
\DoxyCodeLine{02363 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02364 }
\DoxyCodeLine{02365       \textcolor{comment}{/* Carry on if continuous mode is disabled */}}
\DoxyCodeLine{02366       \textcolor{keywordflow}{if} (READ\_BIT(tmp\_cfgr, ADC\_CFGR\_CONT) != ADC\_CFGR\_CONT)}
\DoxyCodeLine{02367       \{}
\DoxyCodeLine{02368         \textcolor{comment}{/* If End of Sequence is reached, disable interrupts */}}
\DoxyCodeLine{02369         \textcolor{keywordflow}{if} (\_\_HAL\_ADC\_GET\_FLAG(hadc, ADC\_FLAG\_EOS))}
\DoxyCodeLine{02370         \{}
\DoxyCodeLine{02371           \textcolor{comment}{/* Allowed to modify bits ADC\_IT\_EOC/ADC\_IT\_EOS only if bit         */}}
\DoxyCodeLine{02372           \textcolor{comment}{/* ADSTART==0 (no conversion on going)                              */}}
\DoxyCodeLine{02373           \textcolor{keywordflow}{if} (LL\_ADC\_REG\_IsConversionOngoing(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{02374           \{}
\DoxyCodeLine{02375             \textcolor{comment}{/* Disable ADC end of sequence conversion interrupt */}}
\DoxyCodeLine{02376             \textcolor{comment}{/* Note: Overrun interrupt was enabled with EOC interrupt in      */}}
\DoxyCodeLine{02377             \textcolor{comment}{/* HAL\_Start\_IT(), but is not disabled here because can be used   */}}
\DoxyCodeLine{02378             \textcolor{comment}{/* by overrun IRQ process below.                                  */}}
\DoxyCodeLine{02379             \_\_HAL\_ADC\_DISABLE\_IT(hadc, ADC\_IT\_EOC | ADC\_IT\_EOS);}
\DoxyCodeLine{02380 }
\DoxyCodeLine{02381             \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{02382             CLEAR\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_REG\_BUSY);}
\DoxyCodeLine{02383 }
\DoxyCodeLine{02384             \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_INJ\_BUSY) == 0UL)}
\DoxyCodeLine{02385             \{}
\DoxyCodeLine{02386               SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_READY);}
\DoxyCodeLine{02387             \}}
\DoxyCodeLine{02388           \}}
\DoxyCodeLine{02389           \textcolor{keywordflow}{else}}
\DoxyCodeLine{02390           \{}
\DoxyCodeLine{02391             \textcolor{comment}{/* Change ADC state to error state */}}
\DoxyCodeLine{02392             SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_INTERNAL);}
\DoxyCodeLine{02393 }
\DoxyCodeLine{02394             \textcolor{comment}{/* Set ADC error code to ADC peripheral internal error */}}
\DoxyCodeLine{02395             SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_INTERNAL);}
\DoxyCodeLine{02396           \}}
\DoxyCodeLine{02397         \}}
\DoxyCodeLine{02398       \}}
\DoxyCodeLine{02399     \}}
\DoxyCodeLine{02400 }
\DoxyCodeLine{02401     \textcolor{comment}{/* Conversion complete callback */}}
\DoxyCodeLine{02402     \textcolor{comment}{/* Note: Into callback function "{}HAL\_ADC\_ConvCpltCallback()"{},             */}}
\DoxyCodeLine{02403     \textcolor{comment}{/*       to determine if conversion has been triggered from EOC or EOS,   */}}
\DoxyCodeLine{02404     \textcolor{comment}{/*       possibility to use:                                              */}}
\DoxyCodeLine{02405     \textcolor{comment}{/*        "{} if ( \_\_HAL\_ADC\_GET\_FLAG(\&hadc, ADC\_FLAG\_EOS)) "{}               */}}
\DoxyCodeLine{02406 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{02407     hadc-\/>ConvCpltCallback(hadc);}
\DoxyCodeLine{02408 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{02409     HAL\_ADC\_ConvCpltCallback(hadc);}
\DoxyCodeLine{02410 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02411 }
\DoxyCodeLine{02412     \textcolor{comment}{/* Clear regular group conversion flag */}}
\DoxyCodeLine{02413     \textcolor{comment}{/* Note: in case of overrun set to ADC\_OVR\_DATA\_PRESERVED, end of         */}}
\DoxyCodeLine{02414     \textcolor{comment}{/*       conversion flags clear induces the release of the preserved data.*/}}
\DoxyCodeLine{02415     \textcolor{comment}{/*       Therefore, if the preserved data value is needed, it must be     */}}
\DoxyCodeLine{02416     \textcolor{comment}{/*       read preliminarily into HAL\_ADC\_ConvCpltCallback().              */}}
\DoxyCodeLine{02417     \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, (ADC\_FLAG\_EOC | ADC\_FLAG\_EOS));}
\DoxyCodeLine{02418   \}}
\DoxyCodeLine{02419 }
\DoxyCodeLine{02420   \textcolor{comment}{/* ====== Check ADC group injected end of unitary conversion sequence conversions ===== */}}
\DoxyCodeLine{02421   \textcolor{keywordflow}{if} ((((tmp\_isr \& ADC\_FLAG\_JEOC) == ADC\_FLAG\_JEOC) \&\& ((tmp\_ier \& ADC\_IT\_JEOC) == ADC\_IT\_JEOC)) ||}
\DoxyCodeLine{02422       (((tmp\_isr \& ADC\_FLAG\_JEOS) == ADC\_FLAG\_JEOS) \&\& ((tmp\_ier \& ADC\_IT\_JEOS) == ADC\_IT\_JEOS)))}
\DoxyCodeLine{02423   \{}
\DoxyCodeLine{02424     \textcolor{comment}{/* Update state machine on conversion status if not in error state */}}
\DoxyCodeLine{02425     \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_ERROR\_INTERNAL) == 0UL)}
\DoxyCodeLine{02426     \{}
\DoxyCodeLine{02427       \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{02428       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_INJ\_EOC);}
\DoxyCodeLine{02429     \}}
\DoxyCodeLine{02430 }
\DoxyCodeLine{02431     \textcolor{comment}{/* Retrieve ADC configuration */}}
\DoxyCodeLine{02432     tmp\_adc\_inj\_is\_trigger\_source\_sw\_start = LL\_ADC\_INJ\_IsTriggerSourceSWStart(hadc-\/>Instance);}
\DoxyCodeLine{02433     tmp\_adc\_reg\_is\_trigger\_source\_sw\_start = LL\_ADC\_REG\_IsTriggerSourceSWStart(hadc-\/>Instance);}
\DoxyCodeLine{02434     \textcolor{comment}{/* Get relevant register CFGR in ADC instance of ADC master or slave  */}}
\DoxyCodeLine{02435     \textcolor{comment}{/* in function of multimode state (for devices with multimode         */}}
\DoxyCodeLine{02436     \textcolor{comment}{/* available).                                                        */}}
\DoxyCodeLine{02437 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{02438     \textcolor{keywordflow}{if} ((\_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance) == hadc-\/>Instance)}
\DoxyCodeLine{02439         || (tmp\_multimode\_config == LL\_ADC\_MULTI\_INDEPENDENT)}
\DoxyCodeLine{02440         || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_REG\_SIMULT)}
\DoxyCodeLine{02441         || (tmp\_multimode\_config == LL\_ADC\_MULTI\_DUAL\_REG\_INTERL)}
\DoxyCodeLine{02442        )}
\DoxyCodeLine{02443     \{}
\DoxyCodeLine{02444       tmp\_cfgr = READ\_REG(hadc-\/>Instance-\/>CFGR);}
\DoxyCodeLine{02445     \}}
\DoxyCodeLine{02446     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02447     \{}
\DoxyCodeLine{02448       tmpADC\_Master = \_\_LL\_ADC\_MULTI\_INSTANCE\_MASTER(hadc-\/>Instance);}
\DoxyCodeLine{02449       tmp\_cfgr = READ\_REG(tmpADC\_Master-\/>CFGR);}
\DoxyCodeLine{02450     \}}
\DoxyCodeLine{02451 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{02452     tmp\_cfgr = READ\_REG(hadc-\/>Instance-\/>CFGR);}
\DoxyCodeLine{02453 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02454 }
\DoxyCodeLine{02455     \textcolor{comment}{/* Disable interruption if no further conversion upcoming by injected     */}}
\DoxyCodeLine{02456     \textcolor{comment}{/* external trigger or by automatic injected conversion with regular      */}}
\DoxyCodeLine{02457     \textcolor{comment}{/* group having no further conversion upcoming (same conditions as        */}}
\DoxyCodeLine{02458     \textcolor{comment}{/* regular group interruption disabling above),                           */}}
\DoxyCodeLine{02459     \textcolor{comment}{/* and if injected scan sequence is completed.                            */}}
\DoxyCodeLine{02460     \textcolor{keywordflow}{if} (tmp\_adc\_inj\_is\_trigger\_source\_sw\_start != 0UL)}
\DoxyCodeLine{02461     \{}
\DoxyCodeLine{02462       \textcolor{keywordflow}{if} ((READ\_BIT(tmp\_cfgr, ADC\_CFGR\_JAUTO) == 0UL) ||}
\DoxyCodeLine{02463           ((tmp\_adc\_reg\_is\_trigger\_source\_sw\_start != 0UL) \&\&}
\DoxyCodeLine{02464            (READ\_BIT(tmp\_cfgr, ADC\_CFGR\_CONT) == 0UL)))}
\DoxyCodeLine{02465       \{}
\DoxyCodeLine{02466         \textcolor{comment}{/* If End of Sequence is reached, disable interrupts */}}
\DoxyCodeLine{02467         \textcolor{keywordflow}{if} (\_\_HAL\_ADC\_GET\_FLAG(hadc, ADC\_FLAG\_JEOS))}
\DoxyCodeLine{02468         \{}
\DoxyCodeLine{02469           \textcolor{comment}{/* Particular case if injected contexts queue is enabled:             */}}
\DoxyCodeLine{02470           \textcolor{comment}{/* when the last context has been fully processed, JSQR is reset      */}}
\DoxyCodeLine{02471           \textcolor{comment}{/* by the hardware. Even if no injected conversion is planned to come */}}
\DoxyCodeLine{02472           \textcolor{comment}{/* (queue empty, triggers are ignored), it can start again            */}}
\DoxyCodeLine{02473           \textcolor{comment}{/* immediately after setting a new context (JADSTART is still set).   */}}
\DoxyCodeLine{02474           \textcolor{comment}{/* Therefore, state of HAL ADC injected group is kept to busy.        */}}
\DoxyCodeLine{02475           \textcolor{keywordflow}{if} (READ\_BIT(tmp\_cfgr, ADC\_CFGR\_JQM) == 0UL)}
\DoxyCodeLine{02476           \{}
\DoxyCodeLine{02477             \textcolor{comment}{/* Allowed to modify bits ADC\_IT\_JEOC/ADC\_IT\_JEOS only if bit       */}}
\DoxyCodeLine{02478             \textcolor{comment}{/* JADSTART==0 (no conversion on going)                             */}}
\DoxyCodeLine{02479             \textcolor{keywordflow}{if} (LL\_ADC\_INJ\_IsConversionOngoing(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{02480             \{}
\DoxyCodeLine{02481               \textcolor{comment}{/* Disable ADC end of sequence conversion interrupt  */}}
\DoxyCodeLine{02482               \_\_HAL\_ADC\_DISABLE\_IT(hadc, ADC\_IT\_JEOC | ADC\_IT\_JEOS);}
\DoxyCodeLine{02483 }
\DoxyCodeLine{02484               \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{02485               CLEAR\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_INJ\_BUSY);}
\DoxyCodeLine{02486 }
\DoxyCodeLine{02487               \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_REG\_BUSY) == 0UL)}
\DoxyCodeLine{02488               \{}
\DoxyCodeLine{02489                 SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_READY);}
\DoxyCodeLine{02490               \}}
\DoxyCodeLine{02491             \}}
\DoxyCodeLine{02492             \textcolor{keywordflow}{else}}
\DoxyCodeLine{02493             \{}
\DoxyCodeLine{02494               \textcolor{comment}{/* Update ADC state machine to error */}}
\DoxyCodeLine{02495               SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_INTERNAL);}
\DoxyCodeLine{02496 }
\DoxyCodeLine{02497               \textcolor{comment}{/* Set ADC error code to ADC peripheral internal error */}}
\DoxyCodeLine{02498               SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_INTERNAL);}
\DoxyCodeLine{02499             \}}
\DoxyCodeLine{02500           \}}
\DoxyCodeLine{02501         \}}
\DoxyCodeLine{02502       \}}
\DoxyCodeLine{02503     \}}
\DoxyCodeLine{02504 }
\DoxyCodeLine{02505     \textcolor{comment}{/* Injected Conversion complete callback */}}
\DoxyCodeLine{02506     \textcolor{comment}{/* Note:  HAL\_ADCEx\_InjectedConvCpltCallback can resort to}}
\DoxyCodeLine{02507 \textcolor{comment}{              if (\_\_HAL\_ADC\_GET\_FLAG(\&hadc, ADC\_FLAG\_JEOS)) or}}
\DoxyCodeLine{02508 \textcolor{comment}{              if (\_\_HAL\_ADC\_GET\_FLAG(\&hadc, ADC\_FLAG\_JEOC)) to determine whether}}
\DoxyCodeLine{02509 \textcolor{comment}{              interruption has been triggered by end of conversion or end of}}
\DoxyCodeLine{02510 \textcolor{comment}{              sequence.    */}}
\DoxyCodeLine{02511 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{02512     hadc-\/>InjectedConvCpltCallback(hadc);}
\DoxyCodeLine{02513 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{02514     HAL\_ADCEx\_InjectedConvCpltCallback(hadc);}
\DoxyCodeLine{02515 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02516 }
\DoxyCodeLine{02517     \textcolor{comment}{/* Clear injected group conversion flag */}}
\DoxyCodeLine{02518     \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_JEOC | ADC\_FLAG\_JEOS);}
\DoxyCodeLine{02519   \}}
\DoxyCodeLine{02520 }
\DoxyCodeLine{02521   \textcolor{comment}{/* ========== Check Analog watchdog 1 flag ========== */}}
\DoxyCodeLine{02522   \textcolor{keywordflow}{if} (((tmp\_isr \& ADC\_FLAG\_AWD1) == ADC\_FLAG\_AWD1) \&\& ((tmp\_ier \& ADC\_IT\_AWD1) == ADC\_IT\_AWD1))}
\DoxyCodeLine{02523   \{}
\DoxyCodeLine{02524     \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{02525     SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_AWD1);}
\DoxyCodeLine{02526 }
\DoxyCodeLine{02527     \textcolor{comment}{/* Level out of window 1 callback */}}
\DoxyCodeLine{02528 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{02529     hadc-\/>LevelOutOfWindowCallback(hadc);}
\DoxyCodeLine{02530 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{02531     HAL\_ADC\_LevelOutOfWindowCallback(hadc);}
\DoxyCodeLine{02532 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02533 }
\DoxyCodeLine{02534     \textcolor{comment}{/* Clear ADC analog watchdog flag */}}
\DoxyCodeLine{02535     \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_AWD1);}
\DoxyCodeLine{02536   \}}
\DoxyCodeLine{02537 }
\DoxyCodeLine{02538   \textcolor{comment}{/* ========== Check analog watchdog 2 flag ========== */}}
\DoxyCodeLine{02539   \textcolor{keywordflow}{if} (((tmp\_isr \& ADC\_FLAG\_AWD2) == ADC\_FLAG\_AWD2) \&\& ((tmp\_ier \& ADC\_IT\_AWD2) == ADC\_IT\_AWD2))}
\DoxyCodeLine{02540   \{}
\DoxyCodeLine{02541     \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{02542     SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_AWD2);}
\DoxyCodeLine{02543 }
\DoxyCodeLine{02544     \textcolor{comment}{/* Level out of window 2 callback */}}
\DoxyCodeLine{02545 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{02546     hadc-\/>LevelOutOfWindow2Callback(hadc);}
\DoxyCodeLine{02547 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{02548     HAL\_ADCEx\_LevelOutOfWindow2Callback(hadc);}
\DoxyCodeLine{02549 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02550 }
\DoxyCodeLine{02551     \textcolor{comment}{/* Clear ADC analog watchdog flag */}}
\DoxyCodeLine{02552     \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_AWD2);}
\DoxyCodeLine{02553   \}}
\DoxyCodeLine{02554 }
\DoxyCodeLine{02555   \textcolor{comment}{/* ========== Check analog watchdog 3 flag ========== */}}
\DoxyCodeLine{02556   \textcolor{keywordflow}{if} (((tmp\_isr \& ADC\_FLAG\_AWD3) == ADC\_FLAG\_AWD3) \&\& ((tmp\_ier \& ADC\_IT\_AWD3) == ADC\_IT\_AWD3))}
\DoxyCodeLine{02557   \{}
\DoxyCodeLine{02558     \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{02559     SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_AWD3);}
\DoxyCodeLine{02560 }
\DoxyCodeLine{02561     \textcolor{comment}{/* Level out of window 3 callback */}}
\DoxyCodeLine{02562 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{02563     hadc-\/>LevelOutOfWindow3Callback(hadc);}
\DoxyCodeLine{02564 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{02565     HAL\_ADCEx\_LevelOutOfWindow3Callback(hadc);}
\DoxyCodeLine{02566 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02567 }
\DoxyCodeLine{02568     \textcolor{comment}{/* Clear ADC analog watchdog flag */}}
\DoxyCodeLine{02569     \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_AWD3);}
\DoxyCodeLine{02570   \}}
\DoxyCodeLine{02571 }
\DoxyCodeLine{02572   \textcolor{comment}{/* ========== Check Overrun flag ========== */}}
\DoxyCodeLine{02573   \textcolor{keywordflow}{if} (((tmp\_isr \& ADC\_FLAG\_OVR) == ADC\_FLAG\_OVR) \&\& ((tmp\_ier \& ADC\_IT\_OVR) == ADC\_IT\_OVR))}
\DoxyCodeLine{02574   \{}
\DoxyCodeLine{02575     \textcolor{comment}{/* If overrun is set to overwrite previous data (default setting),        */}}
\DoxyCodeLine{02576     \textcolor{comment}{/* overrun event is not considered as an error.                           */}}
\DoxyCodeLine{02577     \textcolor{comment}{/* (cf ref manual "{}Managing conversions without using the DMA and without */}}
\DoxyCodeLine{02578     \textcolor{comment}{/* overrun "{})                                                             */}}
\DoxyCodeLine{02579     \textcolor{comment}{/* Exception for usage with DMA overrun event always considered as an     */}}
\DoxyCodeLine{02580     \textcolor{comment}{/* error.                                                                 */}}
\DoxyCodeLine{02581     \textcolor{keywordflow}{if} (hadc-\/>Init.Overrun == ADC\_OVR\_DATA\_PRESERVED)}
\DoxyCodeLine{02582     \{}
\DoxyCodeLine{02583       overrun\_error = 1UL;}
\DoxyCodeLine{02584     \}}
\DoxyCodeLine{02585     \textcolor{keywordflow}{else}}
\DoxyCodeLine{02586     \{}
\DoxyCodeLine{02587       \textcolor{comment}{/* Check DMA configuration */}}
\DoxyCodeLine{02588 \textcolor{preprocessor}{\#if defined(ADC\_MULTIMODE\_SUPPORT)}}
\DoxyCodeLine{02589       \textcolor{keywordflow}{if} (tmp\_multimode\_config != LL\_ADC\_MULTI\_INDEPENDENT)}
\DoxyCodeLine{02590       \{}
\DoxyCodeLine{02591         \textcolor{comment}{/* Multimode (when feature is available) is enabled,}}
\DoxyCodeLine{02592 \textcolor{comment}{           Common Control Register MDMA bits must be checked. */}}
\DoxyCodeLine{02593         \textcolor{keywordflow}{if} (LL\_ADC\_GetMultiDMATransfer(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance)) != LL\_ADC\_MULTI\_REG\_DMA\_EACH\_ADC)}
\DoxyCodeLine{02594         \{}
\DoxyCodeLine{02595           overrun\_error = 1UL;}
\DoxyCodeLine{02596         \}}
\DoxyCodeLine{02597       \}}
\DoxyCodeLine{02598       \textcolor{keywordflow}{else}}
\DoxyCodeLine{02599 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{02600       \{}
\DoxyCodeLine{02601         \textcolor{comment}{/* Multimode not set or feature not available or ADC independent */}}
\DoxyCodeLine{02602         \textcolor{keywordflow}{if} ((hadc-\/>Instance-\/>CFGR \& ADC\_CFGR\_DMAEN) != 0UL)}
\DoxyCodeLine{02603         \{}
\DoxyCodeLine{02604           overrun\_error = 1UL;}
\DoxyCodeLine{02605         \}}
\DoxyCodeLine{02606       \}}
\DoxyCodeLine{02607     \}}
\DoxyCodeLine{02608 }
\DoxyCodeLine{02609     \textcolor{keywordflow}{if} (overrun\_error == 1UL)}
\DoxyCodeLine{02610     \{}
\DoxyCodeLine{02611       \textcolor{comment}{/* Change ADC state to error state */}}
\DoxyCodeLine{02612       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_REG\_OVR);}
\DoxyCodeLine{02613 }
\DoxyCodeLine{02614       \textcolor{comment}{/* Set ADC error code to overrun */}}
\DoxyCodeLine{02615       SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_OVR);}
\DoxyCodeLine{02616 }
\DoxyCodeLine{02617       \textcolor{comment}{/* Error callback */}}
\DoxyCodeLine{02618       \textcolor{comment}{/* Note: In case of overrun, ADC conversion data is preserved until     */}}
\DoxyCodeLine{02619       \textcolor{comment}{/*       flag OVR is reset.                                             */}}
\DoxyCodeLine{02620       \textcolor{comment}{/*       Therefore, old ADC conversion data can be retrieved in         */}}
\DoxyCodeLine{02621       \textcolor{comment}{/*       function "{}HAL\_ADC\_ErrorCallback()"{}.                            */}}
\DoxyCodeLine{02622 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{02623       hadc-\/>ErrorCallback(hadc);}
\DoxyCodeLine{02624 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{02625       HAL\_ADC\_ErrorCallback(hadc);}
\DoxyCodeLine{02626 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02627     \}}
\DoxyCodeLine{02628 }
\DoxyCodeLine{02629     \textcolor{comment}{/* Clear ADC overrun flag */}}
\DoxyCodeLine{02630     \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_OVR);}
\DoxyCodeLine{02631   \}}
\DoxyCodeLine{02632 }
\DoxyCodeLine{02633   \textcolor{comment}{/* ========== Check Injected context queue overflow flag ========== */}}
\DoxyCodeLine{02634   \textcolor{keywordflow}{if} (((tmp\_isr \& ADC\_FLAG\_JQOVF) == ADC\_FLAG\_JQOVF) \&\& ((tmp\_ier \& ADC\_IT\_JQOVF) == ADC\_IT\_JQOVF))}
\DoxyCodeLine{02635   \{}
\DoxyCodeLine{02636     \textcolor{comment}{/* Change ADC state to overrun state */}}
\DoxyCodeLine{02637     SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_INJ\_JQOVF);}
\DoxyCodeLine{02638 }
\DoxyCodeLine{02639     \textcolor{comment}{/* Set ADC error code to Injected context queue overflow */}}
\DoxyCodeLine{02640     SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_JQOVF);}
\DoxyCodeLine{02641 }
\DoxyCodeLine{02642     \textcolor{comment}{/* Clear the Injected context queue overflow flag */}}
\DoxyCodeLine{02643     \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_JQOVF);}
\DoxyCodeLine{02644 }
\DoxyCodeLine{02645     \textcolor{comment}{/* Injected context queue overflow callback */}}
\DoxyCodeLine{02646 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{02647     hadc-\/>InjectedQueueOverflowCallback(hadc);}
\DoxyCodeLine{02648 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{02649     HAL\_ADCEx\_InjectedQueueOverflowCallback(hadc);}
\DoxyCodeLine{02650 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{02651   \}}
\DoxyCodeLine{02652 }
\DoxyCodeLine{02653 \}}
\DoxyCodeLine{02654 }
\DoxyCodeLine{02660 \_\_weak \textcolor{keywordtype}{void} HAL\_ADC\_ConvCpltCallback(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{02661 \{}
\DoxyCodeLine{02662   \textcolor{comment}{/* Prevent unused argument(s) compilation warning */}}
\DoxyCodeLine{02663   UNUSED(hadc);}
\DoxyCodeLine{02664 }
\DoxyCodeLine{02665   \textcolor{comment}{/* NOTE : This function should not be modified. When the callback is needed,}}
\DoxyCodeLine{02666 \textcolor{comment}{            function HAL\_ADC\_ConvCpltCallback must be implemented in the user file.}}
\DoxyCodeLine{02667 \textcolor{comment}{   */}}
\DoxyCodeLine{02668 \}}
\DoxyCodeLine{02669 }
\DoxyCodeLine{02675 \_\_weak \textcolor{keywordtype}{void} HAL\_ADC\_ConvHalfCpltCallback(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{02676 \{}
\DoxyCodeLine{02677   \textcolor{comment}{/* Prevent unused argument(s) compilation warning */}}
\DoxyCodeLine{02678   UNUSED(hadc);}
\DoxyCodeLine{02679 }
\DoxyCodeLine{02680   \textcolor{comment}{/* NOTE : This function should not be modified. When the callback is needed,}}
\DoxyCodeLine{02681 \textcolor{comment}{            function HAL\_ADC\_ConvHalfCpltCallback must be implemented in the user file.}}
\DoxyCodeLine{02682 \textcolor{comment}{  */}}
\DoxyCodeLine{02683 \}}
\DoxyCodeLine{02684 }
\DoxyCodeLine{02690 \_\_weak \textcolor{keywordtype}{void} HAL\_ADC\_LevelOutOfWindowCallback(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{02691 \{}
\DoxyCodeLine{02692   \textcolor{comment}{/* Prevent unused argument(s) compilation warning */}}
\DoxyCodeLine{02693   UNUSED(hadc);}
\DoxyCodeLine{02694 }
\DoxyCodeLine{02695   \textcolor{comment}{/* NOTE : This function should not be modified. When the callback is needed,}}
\DoxyCodeLine{02696 \textcolor{comment}{            function HAL\_ADC\_LevelOutOfWindowCallback must be implemented in the user file.}}
\DoxyCodeLine{02697 \textcolor{comment}{  */}}
\DoxyCodeLine{02698 \}}
\DoxyCodeLine{02699 }
\DoxyCodeLine{02712 \_\_weak \textcolor{keywordtype}{void} HAL\_ADC\_ErrorCallback(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{02713 \{}
\DoxyCodeLine{02714   \textcolor{comment}{/* Prevent unused argument(s) compilation warning */}}
\DoxyCodeLine{02715   UNUSED(hadc);}
\DoxyCodeLine{02716 }
\DoxyCodeLine{02717   \textcolor{comment}{/* NOTE : This function should not be modified. When the callback is needed,}}
\DoxyCodeLine{02718 \textcolor{comment}{            function HAL\_ADC\_ErrorCallback must be implemented in the user file.}}
\DoxyCodeLine{02719 \textcolor{comment}{  */}}
\DoxyCodeLine{02720 \}}
\DoxyCodeLine{02721 }
\DoxyCodeLine{02758 HAL\_StatusTypeDef HAL\_ADC\_ConfigChannel(ADC\_HandleTypeDef *hadc, ADC\_ChannelConfTypeDef *sConfig)}
\DoxyCodeLine{02759 \{}
\DoxyCodeLine{02760   HAL\_StatusTypeDef tmp\_hal\_status = HAL\_OK;}
\DoxyCodeLine{02761   uint32\_t tmpOffsetShifted;}
\DoxyCodeLine{02762   uint32\_t tmp\_config\_internal\_channel;}
\DoxyCodeLine{02763   \_\_IO uint32\_t wait\_loop\_index = 0UL;}
\DoxyCodeLine{02764   uint32\_t tmp\_adc\_is\_conversion\_on\_going\_regular;}
\DoxyCodeLine{02765   uint32\_t tmp\_adc\_is\_conversion\_on\_going\_injected;}
\DoxyCodeLine{02766 }
\DoxyCodeLine{02767   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{02768   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{02769   assert\_param(IS\_ADC\_REGULAR\_RANK(sConfig-\/>Rank));}
\DoxyCodeLine{02770   assert\_param(IS\_ADC\_SAMPLE\_TIME(sConfig-\/>SamplingTime));}
\DoxyCodeLine{02771   assert\_param(IS\_ADC\_SINGLE\_DIFFERENTIAL(sConfig-\/>SingleDiff));}
\DoxyCodeLine{02772   assert\_param(IS\_ADC\_OFFSET\_NUMBER(sConfig-\/>OffsetNumber));}
\DoxyCodeLine{02773   assert\_param(IS\_ADC\_RANGE(ADC\_GET\_RESOLUTION(hadc), sConfig-\/>Offset));}
\DoxyCodeLine{02774 }
\DoxyCodeLine{02775   \textcolor{comment}{/* if ROVSE is set, the value of the OFFSETy\_EN bit in ADCx\_OFRy register is}}
\DoxyCodeLine{02776 \textcolor{comment}{     ignored (considered as reset) */}}
\DoxyCodeLine{02777   assert\_param(!((sConfig-\/>OffsetNumber != ADC\_OFFSET\_NONE) \&\& (hadc-\/>Init.OversamplingMode == ENABLE)));}
\DoxyCodeLine{02778 }
\DoxyCodeLine{02779   \textcolor{comment}{/* Verification of channel number */}}
\DoxyCodeLine{02780   \textcolor{keywordflow}{if} (sConfig-\/>SingleDiff != ADC\_DIFFERENTIAL\_ENDED)}
\DoxyCodeLine{02781   \{}
\DoxyCodeLine{02782     assert\_param(IS\_ADC\_CHANNEL(hadc, sConfig-\/>Channel));}
\DoxyCodeLine{02783   \}}
\DoxyCodeLine{02784   \textcolor{keywordflow}{else}}
\DoxyCodeLine{02785   \{}
\DoxyCodeLine{02786     assert\_param(IS\_ADC\_DIFF\_CHANNEL(hadc, sConfig-\/>Channel));}
\DoxyCodeLine{02787   \}}
\DoxyCodeLine{02788 }
\DoxyCodeLine{02789   \textcolor{comment}{/* Process locked */}}
\DoxyCodeLine{02790   \_\_HAL\_LOCK(hadc);}
\DoxyCodeLine{02791 }
\DoxyCodeLine{02792   \textcolor{comment}{/* Parameters update conditioned to ADC state:                              */}}
\DoxyCodeLine{02793   \textcolor{comment}{/* Parameters that can be updated when ADC is disabled or enabled without   */}}
\DoxyCodeLine{02794   \textcolor{comment}{/* conversion on going on regular group:                                    */}}
\DoxyCodeLine{02795   \textcolor{comment}{/*  -\/ Channel number                                                        */}}
\DoxyCodeLine{02796   \textcolor{comment}{/*  -\/ Channel rank                                                          */}}
\DoxyCodeLine{02797   \textcolor{keywordflow}{if} (LL\_ADC\_REG\_IsConversionOngoing(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{02798   \{}
\DoxyCodeLine{02799     \textcolor{comment}{/* Set ADC group regular sequence: channel on the selected scan sequence rank */}}
\DoxyCodeLine{02800     LL\_ADC\_REG\_SetSequencerRanks(hadc-\/>Instance, sConfig-\/>Rank, sConfig-\/>Channel);}
\DoxyCodeLine{02801 }
\DoxyCodeLine{02802     \textcolor{comment}{/* Parameters update conditioned to ADC state:                              */}}
\DoxyCodeLine{02803     \textcolor{comment}{/* Parameters that can be updated when ADC is disabled or enabled without   */}}
\DoxyCodeLine{02804     \textcolor{comment}{/* conversion on going on regular group:                                    */}}
\DoxyCodeLine{02805     \textcolor{comment}{/*  -\/ Channel sampling time                                                 */}}
\DoxyCodeLine{02806     \textcolor{comment}{/*  -\/ Channel offset                                                        */}}
\DoxyCodeLine{02807     tmp\_adc\_is\_conversion\_on\_going\_regular = LL\_ADC\_REG\_IsConversionOngoing(hadc-\/>Instance);}
\DoxyCodeLine{02808     tmp\_adc\_is\_conversion\_on\_going\_injected = LL\_ADC\_INJ\_IsConversionOngoing(hadc-\/>Instance);}
\DoxyCodeLine{02809     \textcolor{keywordflow}{if} ((tmp\_adc\_is\_conversion\_on\_going\_regular == 0UL)}
\DoxyCodeLine{02810         \&\& (tmp\_adc\_is\_conversion\_on\_going\_injected == 0UL)}
\DoxyCodeLine{02811        )}
\DoxyCodeLine{02812     \{}
\DoxyCodeLine{02813       \textcolor{comment}{/* Manage specific case of sampling time 3.5 cycles replacing 2.5 cyles */}}
\DoxyCodeLine{02814       \textcolor{keywordflow}{if} (sConfig-\/>SamplingTime == ADC\_SAMPLETIME\_3CYCLES\_5)}
\DoxyCodeLine{02815       \{}
\DoxyCodeLine{02816         \textcolor{comment}{/* Set sampling time of the selected ADC channel */}}
\DoxyCodeLine{02817         LL\_ADC\_SetChannelSamplingTime(hadc-\/>Instance, sConfig-\/>Channel, LL\_ADC\_SAMPLINGTIME\_2CYCLES\_5);}
\DoxyCodeLine{02818 }
\DoxyCodeLine{02819         \textcolor{comment}{/* Set ADC sampling time common configuration */}}
\DoxyCodeLine{02820         LL\_ADC\_SetSamplingTimeCommonConfig(hadc-\/>Instance, LL\_ADC\_SAMPLINGTIME\_COMMON\_3C5\_REPL\_2C5);}
\DoxyCodeLine{02821       \}}
\DoxyCodeLine{02822       \textcolor{keywordflow}{else}}
\DoxyCodeLine{02823       \{}
\DoxyCodeLine{02824         \textcolor{comment}{/* Set sampling time of the selected ADC channel */}}
\DoxyCodeLine{02825         LL\_ADC\_SetChannelSamplingTime(hadc-\/>Instance, sConfig-\/>Channel, sConfig-\/>SamplingTime);}
\DoxyCodeLine{02826 }
\DoxyCodeLine{02827         \textcolor{comment}{/* Set ADC sampling time common configuration */}}
\DoxyCodeLine{02828         LL\_ADC\_SetSamplingTimeCommonConfig(hadc-\/>Instance, LL\_ADC\_SAMPLINGTIME\_COMMON\_DEFAULT);}
\DoxyCodeLine{02829       \}}
\DoxyCodeLine{02830 }
\DoxyCodeLine{02831       \textcolor{comment}{/* Configure the offset: offset enable/disable, channel, offset value */}}
\DoxyCodeLine{02832 }
\DoxyCodeLine{02833       \textcolor{comment}{/* Shift the offset with respect to the selected ADC resolution. */}}
\DoxyCodeLine{02834       \textcolor{comment}{/* Offset has to be left-\/aligned on bit 11, the LSB (right bits) are set to 0 */}}
\DoxyCodeLine{02835       tmpOffsetShifted = ADC\_OFFSET\_SHIFT\_RESOLUTION(hadc, (uint32\_t)sConfig-\/>Offset);}
\DoxyCodeLine{02836 }
\DoxyCodeLine{02837       \textcolor{keywordflow}{if} (sConfig-\/>OffsetNumber != ADC\_OFFSET\_NONE)}
\DoxyCodeLine{02838       \{}
\DoxyCodeLine{02839         \textcolor{comment}{/* Set ADC selected offset number */}}
\DoxyCodeLine{02840         LL\_ADC\_SetOffset(hadc-\/>Instance, sConfig-\/>OffsetNumber, sConfig-\/>Channel, tmpOffsetShifted);}
\DoxyCodeLine{02841 }
\DoxyCodeLine{02842         assert\_param(IS\_ADC\_OFFSET\_SIGN(sConfig-\/>OffsetSign));}
\DoxyCodeLine{02843         assert\_param(IS\_FUNCTIONAL\_STATE(sConfig-\/>OffsetSaturation));}
\DoxyCodeLine{02844         \textcolor{comment}{/* Set ADC selected offset sign \& saturation */}}
\DoxyCodeLine{02845         LL\_ADC\_SetOffsetSign(hadc-\/>Instance, sConfig-\/>OffsetNumber, sConfig-\/>OffsetSign);}
\DoxyCodeLine{02846         LL\_ADC\_SetOffsetSaturation(hadc-\/>Instance, sConfig-\/>OffsetNumber, (sConfig-\/>OffsetSaturation == ENABLE) ? LL\_ADC\_OFFSET\_SATURATION\_ENABLE : LL\_ADC\_OFFSET\_SATURATION\_DISABLE);}
\DoxyCodeLine{02847       \}}
\DoxyCodeLine{02848       \textcolor{keywordflow}{else}}
\DoxyCodeLine{02849       \{}
\DoxyCodeLine{02850         \textcolor{comment}{/* Scan each offset register to check if the selected channel is targeted. */}}
\DoxyCodeLine{02851         \textcolor{comment}{/* If this is the case, the corresponding offset number is disabled.       */}}
\DoxyCodeLine{02852         \textcolor{keywordflow}{if} (\_\_LL\_ADC\_CHANNEL\_TO\_DECIMAL\_NB(LL\_ADC\_GetOffsetChannel(hadc-\/>Instance, LL\_ADC\_OFFSET\_1))}
\DoxyCodeLine{02853             == \_\_LL\_ADC\_CHANNEL\_TO\_DECIMAL\_NB(sConfig-\/>Channel))}
\DoxyCodeLine{02854         \{}
\DoxyCodeLine{02855           LL\_ADC\_SetOffsetState(hadc-\/>Instance, LL\_ADC\_OFFSET\_1, LL\_ADC\_OFFSET\_DISABLE);}
\DoxyCodeLine{02856         \}}
\DoxyCodeLine{02857         \textcolor{keywordflow}{if} (\_\_LL\_ADC\_CHANNEL\_TO\_DECIMAL\_NB(LL\_ADC\_GetOffsetChannel(hadc-\/>Instance, LL\_ADC\_OFFSET\_2))}
\DoxyCodeLine{02858             == \_\_LL\_ADC\_CHANNEL\_TO\_DECIMAL\_NB(sConfig-\/>Channel))}
\DoxyCodeLine{02859         \{}
\DoxyCodeLine{02860           LL\_ADC\_SetOffsetState(hadc-\/>Instance, LL\_ADC\_OFFSET\_2, LL\_ADC\_OFFSET\_DISABLE);}
\DoxyCodeLine{02861         \}}
\DoxyCodeLine{02862         \textcolor{keywordflow}{if} (\_\_LL\_ADC\_CHANNEL\_TO\_DECIMAL\_NB(LL\_ADC\_GetOffsetChannel(hadc-\/>Instance, LL\_ADC\_OFFSET\_3))}
\DoxyCodeLine{02863             == \_\_LL\_ADC\_CHANNEL\_TO\_DECIMAL\_NB(sConfig-\/>Channel))}
\DoxyCodeLine{02864         \{}
\DoxyCodeLine{02865           LL\_ADC\_SetOffsetState(hadc-\/>Instance, LL\_ADC\_OFFSET\_3, LL\_ADC\_OFFSET\_DISABLE);}
\DoxyCodeLine{02866         \}}
\DoxyCodeLine{02867         \textcolor{keywordflow}{if} (\_\_LL\_ADC\_CHANNEL\_TO\_DECIMAL\_NB(LL\_ADC\_GetOffsetChannel(hadc-\/>Instance, LL\_ADC\_OFFSET\_4))}
\DoxyCodeLine{02868             == \_\_LL\_ADC\_CHANNEL\_TO\_DECIMAL\_NB(sConfig-\/>Channel))}
\DoxyCodeLine{02869         \{}
\DoxyCodeLine{02870           LL\_ADC\_SetOffsetState(hadc-\/>Instance, LL\_ADC\_OFFSET\_4, LL\_ADC\_OFFSET\_DISABLE);}
\DoxyCodeLine{02871         \}}
\DoxyCodeLine{02872       \}}
\DoxyCodeLine{02873     \}}
\DoxyCodeLine{02874 }
\DoxyCodeLine{02875     \textcolor{comment}{/* Parameters update conditioned to ADC state:                              */}}
\DoxyCodeLine{02876     \textcolor{comment}{/* Parameters that can be updated only when ADC is disabled:                */}}
\DoxyCodeLine{02877     \textcolor{comment}{/*  -\/ Single or differential mode                                           */}}
\DoxyCodeLine{02878     \textcolor{keywordflow}{if} (LL\_ADC\_IsEnabled(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{02879     \{}
\DoxyCodeLine{02880       \textcolor{comment}{/* Set mode single-\/ended or differential input of the selected ADC channel */}}
\DoxyCodeLine{02881       LL\_ADC\_SetChannelSingleDiff(hadc-\/>Instance, sConfig-\/>Channel, sConfig-\/>SingleDiff);}
\DoxyCodeLine{02882 }
\DoxyCodeLine{02883       \textcolor{comment}{/* Configuration of differential mode */}}
\DoxyCodeLine{02884       \textcolor{keywordflow}{if} (sConfig-\/>SingleDiff == ADC\_DIFFERENTIAL\_ENDED)}
\DoxyCodeLine{02885       \{}
\DoxyCodeLine{02886         \textcolor{comment}{/* Set sampling time of the selected ADC channel */}}
\DoxyCodeLine{02887         \textcolor{comment}{/* Note: ADC channel number masked with value "{}0x1F"{} to ensure shift value within 32 bits range */}}
\DoxyCodeLine{02888         LL\_ADC\_SetChannelSamplingTime(hadc-\/>Instance,}
\DoxyCodeLine{02889                                       (uint32\_t)(\_\_LL\_ADC\_DECIMAL\_NB\_TO\_CHANNEL((\_\_LL\_ADC\_CHANNEL\_TO\_DECIMAL\_NB((uint32\_t)sConfig-\/>Channel) + 1UL) \& 0x1FUL)),}
\DoxyCodeLine{02890                                       sConfig-\/>SamplingTime);}
\DoxyCodeLine{02891       \}}
\DoxyCodeLine{02892 }
\DoxyCodeLine{02893     \}}
\DoxyCodeLine{02894 }
\DoxyCodeLine{02895     \textcolor{comment}{/* Management of internal measurement channels: Vbat/VrefInt/TempSensor.  */}}
\DoxyCodeLine{02896     \textcolor{comment}{/* If internal channel selected, enable dedicated internal buffers and    */}}
\DoxyCodeLine{02897     \textcolor{comment}{/* paths.                                                                 */}}
\DoxyCodeLine{02898     \textcolor{comment}{/* Note: these internal measurement paths can be disabled using           */}}
\DoxyCodeLine{02899     \textcolor{comment}{/* HAL\_ADC\_DeInit().                                                      */}}
\DoxyCodeLine{02900 }
\DoxyCodeLine{02901     \textcolor{keywordflow}{if} (\_\_LL\_ADC\_IS\_CHANNEL\_INTERNAL(sConfig-\/>Channel))}
\DoxyCodeLine{02902     \{}
\DoxyCodeLine{02903       tmp\_config\_internal\_channel = LL\_ADC\_GetCommonPathInternalCh(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{02904 }
\DoxyCodeLine{02905       \textcolor{comment}{/* If the requested internal measurement path has already been enabled, */}}
\DoxyCodeLine{02906       \textcolor{comment}{/* bypass the configuration processing.                                 */}}
\DoxyCodeLine{02907       \textcolor{keywordflow}{if} (((sConfig-\/>Channel == ADC\_CHANNEL\_TEMPSENSOR\_ADC1) || (sConfig-\/>Channel == ADC\_CHANNEL\_TEMPSENSOR\_ADC5))}
\DoxyCodeLine{02908           \&\& ((tmp\_config\_internal\_channel \& LL\_ADC\_PATH\_INTERNAL\_TEMPSENSOR) == 0UL))}
\DoxyCodeLine{02909       \{}
\DoxyCodeLine{02910         \textcolor{keywordflow}{if} (ADC\_TEMPERATURE\_SENSOR\_INSTANCE(hadc))}
\DoxyCodeLine{02911         \{}
\DoxyCodeLine{02912           LL\_ADC\_SetCommonPathInternalCh(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance),}
\DoxyCodeLine{02913                                          LL\_ADC\_PATH\_INTERNAL\_TEMPSENSOR | tmp\_config\_internal\_channel);}
\DoxyCodeLine{02914 }
\DoxyCodeLine{02915           \textcolor{comment}{/* Delay for temperature sensor stabilization time */}}
\DoxyCodeLine{02916           \textcolor{comment}{/* Wait loop initialization and execution */}}
\DoxyCodeLine{02917           \textcolor{comment}{/* Note: Variable divided by 2 to compensate partially              */}}
\DoxyCodeLine{02918           \textcolor{comment}{/*       CPU processing cycles, scaling in us split to not          */}}
\DoxyCodeLine{02919           \textcolor{comment}{/*       exceed 32 bits register capacity and handle low frequency. */}}
\DoxyCodeLine{02920           wait\_loop\_index = ((LL\_ADC\_DELAY\_TEMPSENSOR\_STAB\_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));}
\DoxyCodeLine{02921           \textcolor{keywordflow}{while} (wait\_loop\_index != 0UL)}
\DoxyCodeLine{02922           \{}
\DoxyCodeLine{02923             wait\_loop\_index-\/-\/;}
\DoxyCodeLine{02924           \}}
\DoxyCodeLine{02925         \}}
\DoxyCodeLine{02926       \}}
\DoxyCodeLine{02927       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((sConfig-\/>Channel == ADC\_CHANNEL\_VBAT) \&\& ((tmp\_config\_internal\_channel \& LL\_ADC\_PATH\_INTERNAL\_VBAT) == 0UL))}
\DoxyCodeLine{02928       \{}
\DoxyCodeLine{02929         \textcolor{keywordflow}{if} (ADC\_BATTERY\_VOLTAGE\_INSTANCE(hadc))}
\DoxyCodeLine{02930         \{}
\DoxyCodeLine{02931           LL\_ADC\_SetCommonPathInternalCh(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance),}
\DoxyCodeLine{02932                                          LL\_ADC\_PATH\_INTERNAL\_VBAT | tmp\_config\_internal\_channel);}
\DoxyCodeLine{02933         \}}
\DoxyCodeLine{02934       \}}
\DoxyCodeLine{02935       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((sConfig-\/>Channel == ADC\_CHANNEL\_VREFINT)}
\DoxyCodeLine{02936                \&\& ((tmp\_config\_internal\_channel \& LL\_ADC\_PATH\_INTERNAL\_VREFINT) == 0UL))}
\DoxyCodeLine{02937       \{}
\DoxyCodeLine{02938         \textcolor{keywordflow}{if} (ADC\_VREFINT\_INSTANCE(hadc))}
\DoxyCodeLine{02939         \{}
\DoxyCodeLine{02940           LL\_ADC\_SetCommonPathInternalCh(\_\_LL\_ADC\_COMMON\_INSTANCE(hadc-\/>Instance),}
\DoxyCodeLine{02941                                          LL\_ADC\_PATH\_INTERNAL\_VREFINT | tmp\_config\_internal\_channel);}
\DoxyCodeLine{02942         \}}
\DoxyCodeLine{02943       \}}
\DoxyCodeLine{02944       \textcolor{keywordflow}{else}}
\DoxyCodeLine{02945       \{}
\DoxyCodeLine{02946         \textcolor{comment}{/* nothing to do */}}
\DoxyCodeLine{02947       \}}
\DoxyCodeLine{02948     \}}
\DoxyCodeLine{02949   \}}
\DoxyCodeLine{02950 }
\DoxyCodeLine{02951   \textcolor{comment}{/* If a conversion is on going on regular group, no update on regular       */}}
\DoxyCodeLine{02952   \textcolor{comment}{/* channel could be done on neither of the channel configuration structure  */}}
\DoxyCodeLine{02953   \textcolor{comment}{/* parameters.                                                              */}}
\DoxyCodeLine{02954   \textcolor{keywordflow}{else}}
\DoxyCodeLine{02955   \{}
\DoxyCodeLine{02956     \textcolor{comment}{/* Update ADC state machine to error */}}
\DoxyCodeLine{02957     SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_CONFIG);}
\DoxyCodeLine{02958 }
\DoxyCodeLine{02959     tmp\_hal\_status = HAL\_ERROR;}
\DoxyCodeLine{02960   \}}
\DoxyCodeLine{02961 }
\DoxyCodeLine{02962   \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{02963   \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{02964 }
\DoxyCodeLine{02965   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{02966   \textcolor{keywordflow}{return} tmp\_hal\_status;}
\DoxyCodeLine{02967 \}}
\DoxyCodeLine{02968 }
\DoxyCodeLine{02991 HAL\_StatusTypeDef HAL\_ADC\_AnalogWDGConfig(ADC\_HandleTypeDef *hadc, ADC\_AnalogWDGConfTypeDef *AnalogWDGConfig)}
\DoxyCodeLine{02992 \{}
\DoxyCodeLine{02993   HAL\_StatusTypeDef tmp\_hal\_status = HAL\_OK;}
\DoxyCodeLine{02994   uint32\_t tmpAWDHighThresholdShifted;}
\DoxyCodeLine{02995   uint32\_t tmpAWDLowThresholdShifted;}
\DoxyCodeLine{02996   uint32\_t tmp\_adc\_is\_conversion\_on\_going\_regular;}
\DoxyCodeLine{02997   uint32\_t tmp\_adc\_is\_conversion\_on\_going\_injected;}
\DoxyCodeLine{02998 }
\DoxyCodeLine{02999   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{03000   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{03001   assert\_param(IS\_ADC\_ANALOG\_WATCHDOG\_NUMBER(AnalogWDGConfig-\/>WatchdogNumber));}
\DoxyCodeLine{03002   assert\_param(IS\_ADC\_ANALOG\_WATCHDOG\_MODE(AnalogWDGConfig-\/>WatchdogMode));}
\DoxyCodeLine{03003   assert\_param(IS\_ADC\_ANALOG\_WATCHDOG\_FILTERING\_MODE(AnalogWDGConfig-\/>FilteringConfig));}
\DoxyCodeLine{03004   assert\_param(IS\_FUNCTIONAL\_STATE(AnalogWDGConfig-\/>ITMode));}
\DoxyCodeLine{03005 }
\DoxyCodeLine{03006   \textcolor{keywordflow}{if} ((AnalogWDGConfig-\/>WatchdogMode == ADC\_ANALOGWATCHDOG\_SINGLE\_REG)     ||}
\DoxyCodeLine{03007       (AnalogWDGConfig-\/>WatchdogMode == ADC\_ANALOGWATCHDOG\_SINGLE\_INJEC)   ||}
\DoxyCodeLine{03008       (AnalogWDGConfig-\/>WatchdogMode == ADC\_ANALOGWATCHDOG\_SINGLE\_REGINJEC))}
\DoxyCodeLine{03009   \{}
\DoxyCodeLine{03010     assert\_param(IS\_ADC\_CHANNEL(hadc, AnalogWDGConfig-\/>Channel));}
\DoxyCodeLine{03011   \}}
\DoxyCodeLine{03012 }
\DoxyCodeLine{03013   \textcolor{comment}{/* Verify thresholds range */}}
\DoxyCodeLine{03014   \textcolor{keywordflow}{if} (hadc-\/>Init.OversamplingMode == ENABLE)}
\DoxyCodeLine{03015   \{}
\DoxyCodeLine{03016     \textcolor{comment}{/* Case of oversampling enabled: depending on ratio and shift configuration,}}
\DoxyCodeLine{03017 \textcolor{comment}{       analog watchdog thresholds can be higher than ADC resolution.}}
\DoxyCodeLine{03018 \textcolor{comment}{       Verify if thresholds are within maximum thresholds range. */}}
\DoxyCodeLine{03019     assert\_param(IS\_ADC\_RANGE(ADC\_RESOLUTION\_12B, AnalogWDGConfig-\/>HighThreshold));}
\DoxyCodeLine{03020     assert\_param(IS\_ADC\_RANGE(ADC\_RESOLUTION\_12B, AnalogWDGConfig-\/>LowThreshold));}
\DoxyCodeLine{03021   \}}
\DoxyCodeLine{03022   \textcolor{keywordflow}{else}}
\DoxyCodeLine{03023   \{}
\DoxyCodeLine{03024     \textcolor{comment}{/* Verify if thresholds are within the selected ADC resolution */}}
\DoxyCodeLine{03025     assert\_param(IS\_ADC\_RANGE(ADC\_GET\_RESOLUTION(hadc), AnalogWDGConfig-\/>HighThreshold));}
\DoxyCodeLine{03026     assert\_param(IS\_ADC\_RANGE(ADC\_GET\_RESOLUTION(hadc), AnalogWDGConfig-\/>LowThreshold));}
\DoxyCodeLine{03027   \}}
\DoxyCodeLine{03028 }
\DoxyCodeLine{03029   \textcolor{comment}{/* Process locked */}}
\DoxyCodeLine{03030   \_\_HAL\_LOCK(hadc);}
\DoxyCodeLine{03031 }
\DoxyCodeLine{03032   \textcolor{comment}{/* Parameters update conditioned to ADC state:                              */}}
\DoxyCodeLine{03033   \textcolor{comment}{/* Parameters that can be updated when ADC is disabled or enabled without   */}}
\DoxyCodeLine{03034   \textcolor{comment}{/* conversion on going on ADC groups regular and injected:                  */}}
\DoxyCodeLine{03035   \textcolor{comment}{/*  -\/ Analog watchdog channels                                              */}}
\DoxyCodeLine{03036   tmp\_adc\_is\_conversion\_on\_going\_regular = LL\_ADC\_REG\_IsConversionOngoing(hadc-\/>Instance);}
\DoxyCodeLine{03037   tmp\_adc\_is\_conversion\_on\_going\_injected = LL\_ADC\_INJ\_IsConversionOngoing(hadc-\/>Instance);}
\DoxyCodeLine{03038   \textcolor{keywordflow}{if} ((tmp\_adc\_is\_conversion\_on\_going\_regular == 0UL)}
\DoxyCodeLine{03039       \&\& (tmp\_adc\_is\_conversion\_on\_going\_injected == 0UL)}
\DoxyCodeLine{03040      )}
\DoxyCodeLine{03041   \{}
\DoxyCodeLine{03042     \textcolor{comment}{/* Analog watchdog configuration */}}
\DoxyCodeLine{03043     \textcolor{keywordflow}{if} (AnalogWDGConfig-\/>WatchdogNumber == ADC\_ANALOGWATCHDOG\_1)}
\DoxyCodeLine{03044     \{}
\DoxyCodeLine{03045       \textcolor{comment}{/* Configuration of analog watchdog:                                    */}}
\DoxyCodeLine{03046       \textcolor{comment}{/*  -\/ Set the analog watchdog enable mode: one or overall group of      */}}
\DoxyCodeLine{03047       \textcolor{comment}{/*    channels, on groups regular and-\/or injected.                      */}}
\DoxyCodeLine{03048       \textcolor{keywordflow}{switch} (AnalogWDGConfig-\/>WatchdogMode)}
\DoxyCodeLine{03049       \{}
\DoxyCodeLine{03050         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_SINGLE\_REG:}
\DoxyCodeLine{03051           LL\_ADC\_SetAnalogWDMonitChannels(hadc-\/>Instance, LL\_ADC\_AWD1, \_\_LL\_ADC\_ANALOGWD\_CHANNEL\_GROUP(AnalogWDGConfig-\/>Channel,}
\DoxyCodeLine{03052                                           LL\_ADC\_GROUP\_REGULAR));}
\DoxyCodeLine{03053           \textcolor{keywordflow}{break};}
\DoxyCodeLine{03054 }
\DoxyCodeLine{03055         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_SINGLE\_INJEC:}
\DoxyCodeLine{03056           LL\_ADC\_SetAnalogWDMonitChannels(hadc-\/>Instance, LL\_ADC\_AWD1, \_\_LL\_ADC\_ANALOGWD\_CHANNEL\_GROUP(AnalogWDGConfig-\/>Channel,}
\DoxyCodeLine{03057                                           LL\_ADC\_GROUP\_INJECTED));}
\DoxyCodeLine{03058           \textcolor{keywordflow}{break};}
\DoxyCodeLine{03059 }
\DoxyCodeLine{03060         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_SINGLE\_REGINJEC:}
\DoxyCodeLine{03061           LL\_ADC\_SetAnalogWDMonitChannels(hadc-\/>Instance, LL\_ADC\_AWD1, \_\_LL\_ADC\_ANALOGWD\_CHANNEL\_GROUP(AnalogWDGConfig-\/>Channel,}
\DoxyCodeLine{03062                                           LL\_ADC\_GROUP\_REGULAR\_INJECTED));}
\DoxyCodeLine{03063           \textcolor{keywordflow}{break};}
\DoxyCodeLine{03064 }
\DoxyCodeLine{03065         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_ALL\_REG:}
\DoxyCodeLine{03066           LL\_ADC\_SetAnalogWDMonitChannels(hadc-\/>Instance, LL\_ADC\_AWD1, LL\_ADC\_AWD\_ALL\_CHANNELS\_REG);}
\DoxyCodeLine{03067           \textcolor{keywordflow}{break};}
\DoxyCodeLine{03068 }
\DoxyCodeLine{03069         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_ALL\_INJEC:}
\DoxyCodeLine{03070           LL\_ADC\_SetAnalogWDMonitChannels(hadc-\/>Instance, LL\_ADC\_AWD1, LL\_ADC\_AWD\_ALL\_CHANNELS\_INJ);}
\DoxyCodeLine{03071           \textcolor{keywordflow}{break};}
\DoxyCodeLine{03072 }
\DoxyCodeLine{03073         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_ALL\_REGINJEC:}
\DoxyCodeLine{03074           LL\_ADC\_SetAnalogWDMonitChannels(hadc-\/>Instance, LL\_ADC\_AWD1, LL\_ADC\_AWD\_ALL\_CHANNELS\_REG\_INJ);}
\DoxyCodeLine{03075           \textcolor{keywordflow}{break};}
\DoxyCodeLine{03076 }
\DoxyCodeLine{03077         \textcolor{keywordflow}{default}: \textcolor{comment}{/* ADC\_ANALOGWATCHDOG\_NONE */}}
\DoxyCodeLine{03078           LL\_ADC\_SetAnalogWDMonitChannels(hadc-\/>Instance, LL\_ADC\_AWD1, LL\_ADC\_AWD\_DISABLE);}
\DoxyCodeLine{03079           \textcolor{keywordflow}{break};}
\DoxyCodeLine{03080       \}}
\DoxyCodeLine{03081 }
\DoxyCodeLine{03082       \textcolor{comment}{/* Set the filtering configuration */}}
\DoxyCodeLine{03083       MODIFY\_REG(hadc-\/>Instance-\/>TR1,}
\DoxyCodeLine{03084                  ADC\_TR1\_AWDFILT,}
\DoxyCodeLine{03085                  AnalogWDGConfig-\/>FilteringConfig);}
\DoxyCodeLine{03086 }
\DoxyCodeLine{03087       \textcolor{comment}{/* Update state, clear previous result related to AWD1 */}}
\DoxyCodeLine{03088       CLEAR\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_AWD1);}
\DoxyCodeLine{03089 }
\DoxyCodeLine{03090       \textcolor{comment}{/* Clear flag ADC analog watchdog */}}
\DoxyCodeLine{03091       \textcolor{comment}{/* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */}}
\DoxyCodeLine{03092       \textcolor{comment}{/* to use for HAL\_ADC\_IRQHandler() or HAL\_ADC\_PollForEvent()          */}}
\DoxyCodeLine{03093       \textcolor{comment}{/* (in case left enabled by previous ADC operations).                 */}}
\DoxyCodeLine{03094       LL\_ADC\_ClearFlag\_AWD1(hadc-\/>Instance);}
\DoxyCodeLine{03095 }
\DoxyCodeLine{03096       \textcolor{comment}{/* Configure ADC analog watchdog interrupt */}}
\DoxyCodeLine{03097       \textcolor{keywordflow}{if} (AnalogWDGConfig-\/>ITMode == ENABLE)}
\DoxyCodeLine{03098       \{}
\DoxyCodeLine{03099         LL\_ADC\_EnableIT\_AWD1(hadc-\/>Instance);}
\DoxyCodeLine{03100       \}}
\DoxyCodeLine{03101       \textcolor{keywordflow}{else}}
\DoxyCodeLine{03102       \{}
\DoxyCodeLine{03103         LL\_ADC\_DisableIT\_AWD1(hadc-\/>Instance);}
\DoxyCodeLine{03104       \}}
\DoxyCodeLine{03105     \}}
\DoxyCodeLine{03106     \textcolor{comment}{/* Case of ADC\_ANALOGWATCHDOG\_2 or ADC\_ANALOGWATCHDOG\_3 */}}
\DoxyCodeLine{03107     \textcolor{keywordflow}{else}}
\DoxyCodeLine{03108     \{}
\DoxyCodeLine{03109       \textcolor{keywordflow}{switch} (AnalogWDGConfig-\/>WatchdogMode)}
\DoxyCodeLine{03110       \{}
\DoxyCodeLine{03111         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_SINGLE\_REG:}
\DoxyCodeLine{03112         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_SINGLE\_INJEC:}
\DoxyCodeLine{03113         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_SINGLE\_REGINJEC:}
\DoxyCodeLine{03114           \textcolor{comment}{/* Update AWD by bitfield to keep the possibility to monitor        */}}
\DoxyCodeLine{03115           \textcolor{comment}{/* several channels by successive calls of this function.           */}}
\DoxyCodeLine{03116           \textcolor{keywordflow}{if} (AnalogWDGConfig-\/>WatchdogNumber == ADC\_ANALOGWATCHDOG\_2)}
\DoxyCodeLine{03117           \{}
\DoxyCodeLine{03118             SET\_BIT(hadc-\/>Instance-\/>AWD2CR, (1UL << (\_\_LL\_ADC\_CHANNEL\_TO\_DECIMAL\_NB(AnalogWDGConfig-\/>Channel) \& 0x1FUL)));}
\DoxyCodeLine{03119           \}}
\DoxyCodeLine{03120           \textcolor{keywordflow}{else}}
\DoxyCodeLine{03121           \{}
\DoxyCodeLine{03122             SET\_BIT(hadc-\/>Instance-\/>AWD3CR, (1UL << (\_\_LL\_ADC\_CHANNEL\_TO\_DECIMAL\_NB(AnalogWDGConfig-\/>Channel) \& 0x1FUL)));}
\DoxyCodeLine{03123           \}}
\DoxyCodeLine{03124           \textcolor{keywordflow}{break};}
\DoxyCodeLine{03125 }
\DoxyCodeLine{03126         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_ALL\_REG:}
\DoxyCodeLine{03127         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_ALL\_INJEC:}
\DoxyCodeLine{03128         \textcolor{keywordflow}{case} ADC\_ANALOGWATCHDOG\_ALL\_REGINJEC:}
\DoxyCodeLine{03129           LL\_ADC\_SetAnalogWDMonitChannels(hadc-\/>Instance, AnalogWDGConfig-\/>WatchdogNumber, LL\_ADC\_AWD\_ALL\_CHANNELS\_REG\_INJ);}
\DoxyCodeLine{03130           \textcolor{keywordflow}{break};}
\DoxyCodeLine{03131 }
\DoxyCodeLine{03132         \textcolor{keywordflow}{default}: \textcolor{comment}{/* ADC\_ANALOGWATCHDOG\_NONE */}}
\DoxyCodeLine{03133           LL\_ADC\_SetAnalogWDMonitChannels(hadc-\/>Instance, AnalogWDGConfig-\/>WatchdogNumber, LL\_ADC\_AWD\_DISABLE);}
\DoxyCodeLine{03134           \textcolor{keywordflow}{break};}
\DoxyCodeLine{03135       \}}
\DoxyCodeLine{03136 }
\DoxyCodeLine{03137       \textcolor{keywordflow}{if} (AnalogWDGConfig-\/>WatchdogNumber == ADC\_ANALOGWATCHDOG\_2)}
\DoxyCodeLine{03138       \{}
\DoxyCodeLine{03139         \textcolor{comment}{/* Update state, clear previous result related to AWD2 */}}
\DoxyCodeLine{03140         CLEAR\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_AWD2);}
\DoxyCodeLine{03141 }
\DoxyCodeLine{03142         \textcolor{comment}{/* Clear flag ADC analog watchdog */}}
\DoxyCodeLine{03143         \textcolor{comment}{/* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */}}
\DoxyCodeLine{03144         \textcolor{comment}{/* to use for HAL\_ADC\_IRQHandler() or HAL\_ADC\_PollForEvent()          */}}
\DoxyCodeLine{03145         \textcolor{comment}{/* (in case left enabled by previous ADC operations).                 */}}
\DoxyCodeLine{03146         LL\_ADC\_ClearFlag\_AWD2(hadc-\/>Instance);}
\DoxyCodeLine{03147 }
\DoxyCodeLine{03148         \textcolor{comment}{/* Configure ADC analog watchdog interrupt */}}
\DoxyCodeLine{03149         \textcolor{keywordflow}{if} (AnalogWDGConfig-\/>ITMode == ENABLE)}
\DoxyCodeLine{03150         \{}
\DoxyCodeLine{03151           LL\_ADC\_EnableIT\_AWD2(hadc-\/>Instance);}
\DoxyCodeLine{03152         \}}
\DoxyCodeLine{03153         \textcolor{keywordflow}{else}}
\DoxyCodeLine{03154         \{}
\DoxyCodeLine{03155           LL\_ADC\_DisableIT\_AWD2(hadc-\/>Instance);}
\DoxyCodeLine{03156         \}}
\DoxyCodeLine{03157       \}}
\DoxyCodeLine{03158       \textcolor{comment}{/* (AnalogWDGConfig-\/>WatchdogNumber == ADC\_ANALOGWATCHDOG\_3) */}}
\DoxyCodeLine{03159       \textcolor{keywordflow}{else}}
\DoxyCodeLine{03160       \{}
\DoxyCodeLine{03161         \textcolor{comment}{/* Update state, clear previous result related to AWD3 */}}
\DoxyCodeLine{03162         CLEAR\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_AWD3);}
\DoxyCodeLine{03163 }
\DoxyCodeLine{03164         \textcolor{comment}{/* Clear flag ADC analog watchdog */}}
\DoxyCodeLine{03165         \textcolor{comment}{/* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */}}
\DoxyCodeLine{03166         \textcolor{comment}{/* to use for HAL\_ADC\_IRQHandler() or HAL\_ADC\_PollForEvent()          */}}
\DoxyCodeLine{03167         \textcolor{comment}{/* (in case left enabled by previous ADC operations).                 */}}
\DoxyCodeLine{03168         LL\_ADC\_ClearFlag\_AWD3(hadc-\/>Instance);}
\DoxyCodeLine{03169 }
\DoxyCodeLine{03170         \textcolor{comment}{/* Configure ADC analog watchdog interrupt */}}
\DoxyCodeLine{03171         \textcolor{keywordflow}{if} (AnalogWDGConfig-\/>ITMode == ENABLE)}
\DoxyCodeLine{03172         \{}
\DoxyCodeLine{03173           LL\_ADC\_EnableIT\_AWD3(hadc-\/>Instance);}
\DoxyCodeLine{03174         \}}
\DoxyCodeLine{03175         \textcolor{keywordflow}{else}}
\DoxyCodeLine{03176         \{}
\DoxyCodeLine{03177           LL\_ADC\_DisableIT\_AWD3(hadc-\/>Instance);}
\DoxyCodeLine{03178         \}}
\DoxyCodeLine{03179       \}}
\DoxyCodeLine{03180     \}}
\DoxyCodeLine{03181 }
\DoxyCodeLine{03182   \}}
\DoxyCodeLine{03183 }
\DoxyCodeLine{03184   \textcolor{comment}{/* Analog watchdog thresholds configuration */}}
\DoxyCodeLine{03185   \textcolor{keywordflow}{if} (AnalogWDGConfig-\/>WatchdogNumber == ADC\_ANALOGWATCHDOG\_1)}
\DoxyCodeLine{03186   \{}
\DoxyCodeLine{03187     \textcolor{comment}{/* Shift the offset with respect to the selected ADC resolution:        */}}
\DoxyCodeLine{03188     \textcolor{comment}{/* Thresholds have to be left-\/aligned on bit 11, the LSB (right bits)   */}}
\DoxyCodeLine{03189     \textcolor{comment}{/* are set to 0.                                                        */}}
\DoxyCodeLine{03190     tmpAWDHighThresholdShifted = ADC\_AWD1THRESHOLD\_SHIFT\_RESOLUTION(hadc, AnalogWDGConfig-\/>HighThreshold);}
\DoxyCodeLine{03191     tmpAWDLowThresholdShifted  = ADC\_AWD1THRESHOLD\_SHIFT\_RESOLUTION(hadc, AnalogWDGConfig-\/>LowThreshold);}
\DoxyCodeLine{03192   \}}
\DoxyCodeLine{03193   \textcolor{comment}{/* Case of ADC\_ANALOGWATCHDOG\_2 and ADC\_ANALOGWATCHDOG\_3 */}}
\DoxyCodeLine{03194   \textcolor{keywordflow}{else}}
\DoxyCodeLine{03195   \{}
\DoxyCodeLine{03196     \textcolor{comment}{/* Shift the offset with respect to the selected ADC resolution:        */}}
\DoxyCodeLine{03197     \textcolor{comment}{/* Thresholds have to be left-\/aligned on bit 7, the LSB (right bits)    */}}
\DoxyCodeLine{03198     \textcolor{comment}{/* are set to 0.                                                        */}}
\DoxyCodeLine{03199     tmpAWDHighThresholdShifted = ADC\_AWD23THRESHOLD\_SHIFT\_RESOLUTION(hadc, AnalogWDGConfig-\/>HighThreshold);}
\DoxyCodeLine{03200     tmpAWDLowThresholdShifted  = ADC\_AWD23THRESHOLD\_SHIFT\_RESOLUTION(hadc, AnalogWDGConfig-\/>LowThreshold);}
\DoxyCodeLine{03201   \}}
\DoxyCodeLine{03202 }
\DoxyCodeLine{03203   \textcolor{comment}{/* Set ADC analog watchdog thresholds value of both thresholds high and low */}}
\DoxyCodeLine{03204   LL\_ADC\_ConfigAnalogWDThresholds(hadc-\/>Instance, AnalogWDGConfig-\/>WatchdogNumber, tmpAWDHighThresholdShifted,}
\DoxyCodeLine{03205                                   tmpAWDLowThresholdShifted);}
\DoxyCodeLine{03206 }
\DoxyCodeLine{03207   \textcolor{comment}{/* Process unlocked */}}
\DoxyCodeLine{03208   \_\_HAL\_UNLOCK(hadc);}
\DoxyCodeLine{03209 }
\DoxyCodeLine{03210   \textcolor{comment}{/* Return function status */}}
\DoxyCodeLine{03211   \textcolor{keywordflow}{return} tmp\_hal\_status;}
\DoxyCodeLine{03212 \}}
\DoxyCodeLine{03213 }
\DoxyCodeLine{03214 }
\DoxyCodeLine{03246 uint32\_t HAL\_ADC\_GetState(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{03247 \{}
\DoxyCodeLine{03248   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{03249   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{03250 }
\DoxyCodeLine{03251   \textcolor{comment}{/* Return ADC handle state */}}
\DoxyCodeLine{03252   \textcolor{keywordflow}{return} hadc-\/>State;}
\DoxyCodeLine{03253 \}}
\DoxyCodeLine{03254 }
\DoxyCodeLine{03260 uint32\_t HAL\_ADC\_GetError(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{03261 \{}
\DoxyCodeLine{03262   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{03263   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{03264 }
\DoxyCodeLine{03265   \textcolor{keywordflow}{return} hadc-\/>ErrorCode;}
\DoxyCodeLine{03266 \}}
\DoxyCodeLine{03267 }
\DoxyCodeLine{03290 HAL\_StatusTypeDef ADC\_ConversionStop(ADC\_HandleTypeDef *hadc, uint32\_t ConversionGroup)}
\DoxyCodeLine{03291 \{}
\DoxyCodeLine{03292   uint32\_t tickstart;}
\DoxyCodeLine{03293   uint32\_t Conversion\_Timeout\_CPU\_cycles = 0UL;}
\DoxyCodeLine{03294   uint32\_t conversion\_group\_reassigned = ConversionGroup;}
\DoxyCodeLine{03295   uint32\_t tmp\_ADC\_CR\_ADSTART\_JADSTART;}
\DoxyCodeLine{03296   uint32\_t tmp\_adc\_is\_conversion\_on\_going\_regular;}
\DoxyCodeLine{03297   uint32\_t tmp\_adc\_is\_conversion\_on\_going\_injected;}
\DoxyCodeLine{03298 }
\DoxyCodeLine{03299   \textcolor{comment}{/* Check the parameters */}}
\DoxyCodeLine{03300   assert\_param(IS\_ADC\_ALL\_INSTANCE(hadc-\/>Instance));}
\DoxyCodeLine{03301   assert\_param(IS\_ADC\_CONVERSION\_GROUP(ConversionGroup));}
\DoxyCodeLine{03302 }
\DoxyCodeLine{03303   \textcolor{comment}{/* Verification if ADC is not already stopped (on regular and injected      */}}
\DoxyCodeLine{03304   \textcolor{comment}{/* groups) to bypass this function if not needed.                           */}}
\DoxyCodeLine{03305   tmp\_adc\_is\_conversion\_on\_going\_regular = LL\_ADC\_REG\_IsConversionOngoing(hadc-\/>Instance);}
\DoxyCodeLine{03306   tmp\_adc\_is\_conversion\_on\_going\_injected = LL\_ADC\_INJ\_IsConversionOngoing(hadc-\/>Instance);}
\DoxyCodeLine{03307   \textcolor{keywordflow}{if} ((tmp\_adc\_is\_conversion\_on\_going\_regular != 0UL)}
\DoxyCodeLine{03308       || (tmp\_adc\_is\_conversion\_on\_going\_injected != 0UL)}
\DoxyCodeLine{03309      )}
\DoxyCodeLine{03310   \{}
\DoxyCodeLine{03311     \textcolor{comment}{/* Particular case of continuous auto-\/injection mode combined with        */}}
\DoxyCodeLine{03312     \textcolor{comment}{/* auto-\/delay mode.                                                       */}}
\DoxyCodeLine{03313     \textcolor{comment}{/* In auto-\/injection mode, regular group stop ADC\_CR\_ADSTP is used (not   */}}
\DoxyCodeLine{03314     \textcolor{comment}{/* injected group stop ADC\_CR\_JADSTP).                                    */}}
\DoxyCodeLine{03315     \textcolor{comment}{/* Procedure to be followed: Wait until JEOS=1, clear JEOS, set ADSTP=1   */}}
\DoxyCodeLine{03316     \textcolor{comment}{/* (see reference manual).                                                */}}
\DoxyCodeLine{03317     \textcolor{keywordflow}{if} (((hadc-\/>Instance-\/>CFGR \& ADC\_CFGR\_JAUTO) != 0UL)}
\DoxyCodeLine{03318         \&\& (hadc-\/>Init.ContinuousConvMode == ENABLE)}
\DoxyCodeLine{03319         \&\& (hadc-\/>Init.LowPowerAutoWait == ENABLE)}
\DoxyCodeLine{03320        )}
\DoxyCodeLine{03321     \{}
\DoxyCodeLine{03322       \textcolor{comment}{/* Use stop of regular group */}}
\DoxyCodeLine{03323       conversion\_group\_reassigned = ADC\_REGULAR\_GROUP;}
\DoxyCodeLine{03324 }
\DoxyCodeLine{03325       \textcolor{comment}{/* Wait until JEOS=1 (maximum Timeout: 4 injected conversions) */}}
\DoxyCodeLine{03326       \textcolor{keywordflow}{while} (\_\_HAL\_ADC\_GET\_FLAG(hadc, ADC\_FLAG\_JEOS) == 0UL)}
\DoxyCodeLine{03327       \{}
\DoxyCodeLine{03328         \textcolor{keywordflow}{if} (Conversion\_Timeout\_CPU\_cycles >= (ADC\_CONVERSION\_TIME\_MAX\_CPU\_CYCLES * 4UL))}
\DoxyCodeLine{03329         \{}
\DoxyCodeLine{03330           \textcolor{comment}{/* Update ADC state machine to error */}}
\DoxyCodeLine{03331           SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_INTERNAL);}
\DoxyCodeLine{03332 }
\DoxyCodeLine{03333           \textcolor{comment}{/* Set ADC error code to ADC peripheral internal error */}}
\DoxyCodeLine{03334           SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_INTERNAL);}
\DoxyCodeLine{03335 }
\DoxyCodeLine{03336           \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{03337         \}}
\DoxyCodeLine{03338         Conversion\_Timeout\_CPU\_cycles ++;}
\DoxyCodeLine{03339       \}}
\DoxyCodeLine{03340 }
\DoxyCodeLine{03341       \textcolor{comment}{/* Clear JEOS */}}
\DoxyCodeLine{03342       \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, ADC\_FLAG\_JEOS);}
\DoxyCodeLine{03343     \}}
\DoxyCodeLine{03344 }
\DoxyCodeLine{03345     \textcolor{comment}{/* Stop potential conversion on going on ADC group regular */}}
\DoxyCodeLine{03346     \textcolor{keywordflow}{if} (conversion\_group\_reassigned != ADC\_INJECTED\_GROUP)}
\DoxyCodeLine{03347     \{}
\DoxyCodeLine{03348       \textcolor{comment}{/* Software is allowed to set ADSTP only when ADSTART=1 and ADDIS=0 */}}
\DoxyCodeLine{03349       \textcolor{keywordflow}{if} (LL\_ADC\_REG\_IsConversionOngoing(hadc-\/>Instance) != 0UL)}
\DoxyCodeLine{03350       \{}
\DoxyCodeLine{03351         \textcolor{keywordflow}{if} (LL\_ADC\_IsDisableOngoing(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{03352         \{}
\DoxyCodeLine{03353           \textcolor{comment}{/* Stop ADC group regular conversion */}}
\DoxyCodeLine{03354           LL\_ADC\_REG\_StopConversion(hadc-\/>Instance);}
\DoxyCodeLine{03355         \}}
\DoxyCodeLine{03356       \}}
\DoxyCodeLine{03357     \}}
\DoxyCodeLine{03358 }
\DoxyCodeLine{03359     \textcolor{comment}{/* Stop potential conversion on going on ADC group injected */}}
\DoxyCodeLine{03360     \textcolor{keywordflow}{if} (conversion\_group\_reassigned != ADC\_REGULAR\_GROUP)}
\DoxyCodeLine{03361     \{}
\DoxyCodeLine{03362       \textcolor{comment}{/* Software is allowed to set JADSTP only when JADSTART=1 and ADDIS=0 */}}
\DoxyCodeLine{03363       \textcolor{keywordflow}{if} (LL\_ADC\_INJ\_IsConversionOngoing(hadc-\/>Instance) != 0UL)}
\DoxyCodeLine{03364       \{}
\DoxyCodeLine{03365         \textcolor{keywordflow}{if} (LL\_ADC\_IsDisableOngoing(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{03366         \{}
\DoxyCodeLine{03367           \textcolor{comment}{/* Stop ADC group injected conversion */}}
\DoxyCodeLine{03368           LL\_ADC\_INJ\_StopConversion(hadc-\/>Instance);}
\DoxyCodeLine{03369         \}}
\DoxyCodeLine{03370       \}}
\DoxyCodeLine{03371     \}}
\DoxyCodeLine{03372 }
\DoxyCodeLine{03373     \textcolor{comment}{/* Selection of start and stop bits with respect to the regular or injected group */}}
\DoxyCodeLine{03374     \textcolor{keywordflow}{switch} (conversion\_group\_reassigned)}
\DoxyCodeLine{03375     \{}
\DoxyCodeLine{03376       \textcolor{keywordflow}{case} ADC\_REGULAR\_INJECTED\_GROUP:}
\DoxyCodeLine{03377         tmp\_ADC\_CR\_ADSTART\_JADSTART = (ADC\_CR\_ADSTART | ADC\_CR\_JADSTART);}
\DoxyCodeLine{03378         \textcolor{keywordflow}{break};}
\DoxyCodeLine{03379       \textcolor{keywordflow}{case} ADC\_INJECTED\_GROUP:}
\DoxyCodeLine{03380         tmp\_ADC\_CR\_ADSTART\_JADSTART = ADC\_CR\_JADSTART;}
\DoxyCodeLine{03381         \textcolor{keywordflow}{break};}
\DoxyCodeLine{03382       \textcolor{comment}{/* Case ADC\_REGULAR\_GROUP only*/}}
\DoxyCodeLine{03383       \textcolor{keywordflow}{default}:}
\DoxyCodeLine{03384         tmp\_ADC\_CR\_ADSTART\_JADSTART = ADC\_CR\_ADSTART;}
\DoxyCodeLine{03385         \textcolor{keywordflow}{break};}
\DoxyCodeLine{03386     \}}
\DoxyCodeLine{03387 }
\DoxyCodeLine{03388     \textcolor{comment}{/* Wait for conversion effectively stopped */}}
\DoxyCodeLine{03389     tickstart = HAL\_GetTick();}
\DoxyCodeLine{03390 }
\DoxyCodeLine{03391     \textcolor{keywordflow}{while} ((hadc-\/>Instance-\/>CR \& tmp\_ADC\_CR\_ADSTART\_JADSTART) != 0UL)}
\DoxyCodeLine{03392     \{}
\DoxyCodeLine{03393       \textcolor{keywordflow}{if} ((HAL\_GetTick() -\/ tickstart) > ADC\_STOP\_CONVERSION\_TIMEOUT)}
\DoxyCodeLine{03394       \{}
\DoxyCodeLine{03395         \textcolor{comment}{/* New check to avoid false timeout detection in case of preemption */}}
\DoxyCodeLine{03396         \textcolor{keywordflow}{if} ((hadc-\/>Instance-\/>CR \& tmp\_ADC\_CR\_ADSTART\_JADSTART) != 0UL)}
\DoxyCodeLine{03397         \{}
\DoxyCodeLine{03398           \textcolor{comment}{/* Update ADC state machine to error */}}
\DoxyCodeLine{03399           SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_INTERNAL);}
\DoxyCodeLine{03400 }
\DoxyCodeLine{03401           \textcolor{comment}{/* Set ADC error code to ADC peripheral internal error */}}
\DoxyCodeLine{03402           SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_INTERNAL);}
\DoxyCodeLine{03403 }
\DoxyCodeLine{03404           \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{03405         \}}
\DoxyCodeLine{03406       \}}
\DoxyCodeLine{03407     \}}
\DoxyCodeLine{03408 }
\DoxyCodeLine{03409   \}}
\DoxyCodeLine{03410 }
\DoxyCodeLine{03411   \textcolor{comment}{/* Return HAL status */}}
\DoxyCodeLine{03412   \textcolor{keywordflow}{return} HAL\_OK;}
\DoxyCodeLine{03413 \}}
\DoxyCodeLine{03414 }
\DoxyCodeLine{03422 HAL\_StatusTypeDef ADC\_Enable(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{03423 \{}
\DoxyCodeLine{03424   uint32\_t tickstart;}
\DoxyCodeLine{03425 }
\DoxyCodeLine{03426   \textcolor{comment}{/* ADC enable and wait for ADC ready (in case of ADC is disabled or         */}}
\DoxyCodeLine{03427   \textcolor{comment}{/* enabling phase not yet completed: flag ADC ready not yet set).           */}}
\DoxyCodeLine{03428   \textcolor{comment}{/* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */}}
\DoxyCodeLine{03429   \textcolor{comment}{/* causes: ADC clock not running, ...).                                     */}}
\DoxyCodeLine{03430   \textcolor{keywordflow}{if} (LL\_ADC\_IsEnabled(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{03431   \{}
\DoxyCodeLine{03432     \textcolor{comment}{/* Check if conditions to enable the ADC are fulfilled */}}
\DoxyCodeLine{03433     \textcolor{keywordflow}{if} ((hadc-\/>Instance-\/>CR \& (ADC\_CR\_ADCAL | ADC\_CR\_JADSTP | ADC\_CR\_ADSTP | ADC\_CR\_JADSTART | ADC\_CR\_ADSTART}
\DoxyCodeLine{03434                                | ADC\_CR\_ADDIS | ADC\_CR\_ADEN)) != 0UL)}
\DoxyCodeLine{03435     \{}
\DoxyCodeLine{03436       \textcolor{comment}{/* Update ADC state machine to error */}}
\DoxyCodeLine{03437       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_INTERNAL);}
\DoxyCodeLine{03438 }
\DoxyCodeLine{03439       \textcolor{comment}{/* Set ADC error code to ADC peripheral internal error */}}
\DoxyCodeLine{03440       SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_INTERNAL);}
\DoxyCodeLine{03441 }
\DoxyCodeLine{03442       \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{03443     \}}
\DoxyCodeLine{03444 }
\DoxyCodeLine{03445     \textcolor{comment}{/* Enable the ADC peripheral */}}
\DoxyCodeLine{03446     LL\_ADC\_Enable(hadc-\/>Instance);}
\DoxyCodeLine{03447 }
\DoxyCodeLine{03448     \textcolor{comment}{/* Wait for ADC effectively enabled */}}
\DoxyCodeLine{03449     tickstart = HAL\_GetTick();}
\DoxyCodeLine{03450 }
\DoxyCodeLine{03451     \textcolor{keywordflow}{while} (\_\_HAL\_ADC\_GET\_FLAG(hadc, ADC\_FLAG\_RDY) == 0UL)}
\DoxyCodeLine{03452     \{}
\DoxyCodeLine{03453       \textcolor{comment}{/*  If ADEN bit is set less than 4 ADC clock cycles after the ADCAL bit}}
\DoxyCodeLine{03454 \textcolor{comment}{          has been cleared (after a calibration), ADEN bit is reset by the}}
\DoxyCodeLine{03455 \textcolor{comment}{          calibration logic.}}
\DoxyCodeLine{03456 \textcolor{comment}{          The workaround is to continue setting ADEN until ADRDY is becomes 1.}}
\DoxyCodeLine{03457 \textcolor{comment}{          Additionally, ADC\_ENABLE\_TIMEOUT is defined to encompass this}}
\DoxyCodeLine{03458 \textcolor{comment}{          4 ADC clock cycle duration */}}
\DoxyCodeLine{03459       \textcolor{comment}{/* Note: Test of ADC enabled required due to hardware constraint to     */}}
\DoxyCodeLine{03460       \textcolor{comment}{/*       not enable ADC if already enabled.                             */}}
\DoxyCodeLine{03461       \textcolor{keywordflow}{if} (LL\_ADC\_IsEnabled(hadc-\/>Instance) == 0UL)}
\DoxyCodeLine{03462       \{}
\DoxyCodeLine{03463         LL\_ADC\_Enable(hadc-\/>Instance);}
\DoxyCodeLine{03464       \}}
\DoxyCodeLine{03465 }
\DoxyCodeLine{03466       \textcolor{keywordflow}{if} ((HAL\_GetTick() -\/ tickstart) > ADC\_ENABLE\_TIMEOUT)}
\DoxyCodeLine{03467       \{}
\DoxyCodeLine{03468         \textcolor{comment}{/* New check to avoid false timeout detection in case of preemption */}}
\DoxyCodeLine{03469         \textcolor{keywordflow}{if} (\_\_HAL\_ADC\_GET\_FLAG(hadc, ADC\_FLAG\_RDY) == 0UL)}
\DoxyCodeLine{03470         \{}
\DoxyCodeLine{03471           \textcolor{comment}{/* Update ADC state machine to error */}}
\DoxyCodeLine{03472           SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_INTERNAL);}
\DoxyCodeLine{03473 }
\DoxyCodeLine{03474           \textcolor{comment}{/* Set ADC error code to ADC peripheral internal error */}}
\DoxyCodeLine{03475           SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_INTERNAL);}
\DoxyCodeLine{03476 }
\DoxyCodeLine{03477           \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{03478         \}}
\DoxyCodeLine{03479       \}}
\DoxyCodeLine{03480     \}}
\DoxyCodeLine{03481   \}}
\DoxyCodeLine{03482 }
\DoxyCodeLine{03483   \textcolor{comment}{/* Return HAL status */}}
\DoxyCodeLine{03484   \textcolor{keywordflow}{return} HAL\_OK;}
\DoxyCodeLine{03485 \}}
\DoxyCodeLine{03486 }
\DoxyCodeLine{03494 HAL\_StatusTypeDef ADC\_Disable(ADC\_HandleTypeDef *hadc)}
\DoxyCodeLine{03495 \{}
\DoxyCodeLine{03496   uint32\_t tickstart;}
\DoxyCodeLine{03497   \textcolor{keyword}{const} uint32\_t tmp\_adc\_is\_disable\_on\_going = LL\_ADC\_IsDisableOngoing(hadc-\/>Instance);}
\DoxyCodeLine{03498 }
\DoxyCodeLine{03499   \textcolor{comment}{/* Verification if ADC is not already disabled:                             */}}
\DoxyCodeLine{03500   \textcolor{comment}{/* Note: forbidden to disable ADC (set bit ADC\_CR\_ADDIS) if ADC is already  */}}
\DoxyCodeLine{03501   \textcolor{comment}{/*       disabled.                                                          */}}
\DoxyCodeLine{03502   \textcolor{keywordflow}{if} ((LL\_ADC\_IsEnabled(hadc-\/>Instance) != 0UL)}
\DoxyCodeLine{03503       \&\& (tmp\_adc\_is\_disable\_on\_going == 0UL)}
\DoxyCodeLine{03504      )}
\DoxyCodeLine{03505   \{}
\DoxyCodeLine{03506     \textcolor{comment}{/* Check if conditions to disable the ADC are fulfilled */}}
\DoxyCodeLine{03507     \textcolor{keywordflow}{if} ((hadc-\/>Instance-\/>CR \& (ADC\_CR\_JADSTART | ADC\_CR\_ADSTART | ADC\_CR\_ADEN)) == ADC\_CR\_ADEN)}
\DoxyCodeLine{03508     \{}
\DoxyCodeLine{03509       \textcolor{comment}{/* Disable the ADC peripheral */}}
\DoxyCodeLine{03510       LL\_ADC\_Disable(hadc-\/>Instance);}
\DoxyCodeLine{03511       \_\_HAL\_ADC\_CLEAR\_FLAG(hadc, (ADC\_FLAG\_EOSMP | ADC\_FLAG\_RDY));}
\DoxyCodeLine{03512     \}}
\DoxyCodeLine{03513     \textcolor{keywordflow}{else}}
\DoxyCodeLine{03514     \{}
\DoxyCodeLine{03515       \textcolor{comment}{/* Update ADC state machine to error */}}
\DoxyCodeLine{03516       SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_INTERNAL);}
\DoxyCodeLine{03517 }
\DoxyCodeLine{03518       \textcolor{comment}{/* Set ADC error code to ADC peripheral internal error */}}
\DoxyCodeLine{03519       SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_INTERNAL);}
\DoxyCodeLine{03520 }
\DoxyCodeLine{03521       \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{03522     \}}
\DoxyCodeLine{03523 }
\DoxyCodeLine{03524     \textcolor{comment}{/* Wait for ADC effectively disabled */}}
\DoxyCodeLine{03525     \textcolor{comment}{/* Get tick count */}}
\DoxyCodeLine{03526     tickstart = HAL\_GetTick();}
\DoxyCodeLine{03527 }
\DoxyCodeLine{03528     \textcolor{keywordflow}{while} ((hadc-\/>Instance-\/>CR \& ADC\_CR\_ADEN) != 0UL)}
\DoxyCodeLine{03529     \{}
\DoxyCodeLine{03530       \textcolor{keywordflow}{if} ((HAL\_GetTick() -\/ tickstart) > ADC\_DISABLE\_TIMEOUT)}
\DoxyCodeLine{03531       \{}
\DoxyCodeLine{03532         \textcolor{comment}{/* New check to avoid false timeout detection in case of preemption */}}
\DoxyCodeLine{03533         \textcolor{keywordflow}{if} ((hadc-\/>Instance-\/>CR \& ADC\_CR\_ADEN) != 0UL)}
\DoxyCodeLine{03534         \{}
\DoxyCodeLine{03535           \textcolor{comment}{/* Update ADC state machine to error */}}
\DoxyCodeLine{03536           SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_INTERNAL);}
\DoxyCodeLine{03537 }
\DoxyCodeLine{03538           \textcolor{comment}{/* Set ADC error code to ADC peripheral internal error */}}
\DoxyCodeLine{03539           SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_INTERNAL);}
\DoxyCodeLine{03540 }
\DoxyCodeLine{03541           \textcolor{keywordflow}{return} HAL\_ERROR;}
\DoxyCodeLine{03542         \}}
\DoxyCodeLine{03543       \}}
\DoxyCodeLine{03544     \}}
\DoxyCodeLine{03545   \}}
\DoxyCodeLine{03546 }
\DoxyCodeLine{03547   \textcolor{comment}{/* Return HAL status */}}
\DoxyCodeLine{03548   \textcolor{keywordflow}{return} HAL\_OK;}
\DoxyCodeLine{03549 \}}
\DoxyCodeLine{03550 }
\DoxyCodeLine{03556 \textcolor{keywordtype}{void} ADC\_DMAConvCplt(DMA\_HandleTypeDef *hdma)}
\DoxyCodeLine{03557 \{}
\DoxyCodeLine{03558   \textcolor{comment}{/* Retrieve ADC handle corresponding to current DMA handle */}}
\DoxyCodeLine{03559   ADC\_HandleTypeDef *hadc = (ADC\_HandleTypeDef *)((DMA\_HandleTypeDef *)hdma)-\/>Parent;}
\DoxyCodeLine{03560 }
\DoxyCodeLine{03561   \textcolor{comment}{/* Update state machine on conversion status if not in error state */}}
\DoxyCodeLine{03562   \textcolor{keywordflow}{if} ((hadc-\/>State \& (HAL\_ADC\_STATE\_ERROR\_INTERNAL | HAL\_ADC\_STATE\_ERROR\_DMA)) == 0UL)}
\DoxyCodeLine{03563   \{}
\DoxyCodeLine{03564     \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{03565     SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_REG\_EOC);}
\DoxyCodeLine{03566 }
\DoxyCodeLine{03567     \textcolor{comment}{/* Determine whether any further conversion upcoming on group regular     */}}
\DoxyCodeLine{03568     \textcolor{comment}{/* by external trigger, continuous mode or scan sequence on going         */}}
\DoxyCodeLine{03569     \textcolor{comment}{/* to disable interruption.                                               */}}
\DoxyCodeLine{03570     \textcolor{comment}{/* Is it the end of the regular sequence ? */}}
\DoxyCodeLine{03571     \textcolor{keywordflow}{if} ((hadc-\/>Instance-\/>ISR \& ADC\_FLAG\_EOS) != 0UL)}
\DoxyCodeLine{03572     \{}
\DoxyCodeLine{03573       \textcolor{comment}{/* Are conversions software-\/triggered ? */}}
\DoxyCodeLine{03574       \textcolor{keywordflow}{if} (LL\_ADC\_REG\_IsTriggerSourceSWStart(hadc-\/>Instance) != 0UL)}
\DoxyCodeLine{03575       \{}
\DoxyCodeLine{03576         \textcolor{comment}{/* Is CONT bit set ? */}}
\DoxyCodeLine{03577         \textcolor{keywordflow}{if} (READ\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_CONT) == 0UL)}
\DoxyCodeLine{03578         \{}
\DoxyCodeLine{03579           \textcolor{comment}{/* CONT bit is not set, no more conversions expected */}}
\DoxyCodeLine{03580           CLEAR\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_REG\_BUSY);}
\DoxyCodeLine{03581           \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_INJ\_BUSY) == 0UL)}
\DoxyCodeLine{03582           \{}
\DoxyCodeLine{03583             SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_READY);}
\DoxyCodeLine{03584           \}}
\DoxyCodeLine{03585         \}}
\DoxyCodeLine{03586       \}}
\DoxyCodeLine{03587     \}}
\DoxyCodeLine{03588     \textcolor{keywordflow}{else}}
\DoxyCodeLine{03589     \{}
\DoxyCodeLine{03590       \textcolor{comment}{/* DMA End of Transfer interrupt was triggered but conversions sequence}}
\DoxyCodeLine{03591 \textcolor{comment}{         is not over. If DMACFG is set to 0, conversions are stopped. */}}
\DoxyCodeLine{03592       \textcolor{keywordflow}{if} (READ\_BIT(hadc-\/>Instance-\/>CFGR, ADC\_CFGR\_DMACFG) == 0UL)}
\DoxyCodeLine{03593       \{}
\DoxyCodeLine{03594         \textcolor{comment}{/* DMACFG bit is not set, conversions are stopped. */}}
\DoxyCodeLine{03595         CLEAR\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_REG\_BUSY);}
\DoxyCodeLine{03596         \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_INJ\_BUSY) == 0UL)}
\DoxyCodeLine{03597         \{}
\DoxyCodeLine{03598           SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_READY);}
\DoxyCodeLine{03599         \}}
\DoxyCodeLine{03600       \}}
\DoxyCodeLine{03601     \}}
\DoxyCodeLine{03602 }
\DoxyCodeLine{03603     \textcolor{comment}{/* Conversion complete callback */}}
\DoxyCodeLine{03604 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{03605     hadc-\/>ConvCpltCallback(hadc);}
\DoxyCodeLine{03606 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{03607     HAL\_ADC\_ConvCpltCallback(hadc);}
\DoxyCodeLine{03608 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03609   \}}
\DoxyCodeLine{03610   \textcolor{keywordflow}{else} \textcolor{comment}{/* DMA and-\/or internal error occurred */}}
\DoxyCodeLine{03611   \{}
\DoxyCodeLine{03612     \textcolor{keywordflow}{if} ((hadc-\/>State \& HAL\_ADC\_STATE\_ERROR\_INTERNAL) != 0UL)}
\DoxyCodeLine{03613     \{}
\DoxyCodeLine{03614       \textcolor{comment}{/* Call HAL ADC Error Callback function */}}
\DoxyCodeLine{03615 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{03616       hadc-\/>ErrorCallback(hadc);}
\DoxyCodeLine{03617 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{03618       HAL\_ADC\_ErrorCallback(hadc);}
\DoxyCodeLine{03619 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03620     \}}
\DoxyCodeLine{03621     \textcolor{keywordflow}{else}}
\DoxyCodeLine{03622     \{}
\DoxyCodeLine{03623       \textcolor{comment}{/* Call ADC DMA error callback */}}
\DoxyCodeLine{03624       hadc-\/>DMA\_Handle-\/>XferErrorCallback(hdma);}
\DoxyCodeLine{03625     \}}
\DoxyCodeLine{03626   \}}
\DoxyCodeLine{03627 \}}
\DoxyCodeLine{03628 }
\DoxyCodeLine{03634 \textcolor{keywordtype}{void} ADC\_DMAHalfConvCplt(DMA\_HandleTypeDef *hdma)}
\DoxyCodeLine{03635 \{}
\DoxyCodeLine{03636   \textcolor{comment}{/* Retrieve ADC handle corresponding to current DMA handle */}}
\DoxyCodeLine{03637   ADC\_HandleTypeDef *hadc = (ADC\_HandleTypeDef *)((DMA\_HandleTypeDef *)hdma)-\/>Parent;}
\DoxyCodeLine{03638 }
\DoxyCodeLine{03639   \textcolor{comment}{/* Half conversion callback */}}
\DoxyCodeLine{03640 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{03641   hadc-\/>ConvHalfCpltCallback(hadc);}
\DoxyCodeLine{03642 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{03643   HAL\_ADC\_ConvHalfCpltCallback(hadc);}
\DoxyCodeLine{03644 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03645 \}}
\DoxyCodeLine{03646 }
\DoxyCodeLine{03652 \textcolor{keywordtype}{void} ADC\_DMAError(DMA\_HandleTypeDef *hdma)}
\DoxyCodeLine{03653 \{}
\DoxyCodeLine{03654   \textcolor{comment}{/* Retrieve ADC handle corresponding to current DMA handle */}}
\DoxyCodeLine{03655   ADC\_HandleTypeDef *hadc = (ADC\_HandleTypeDef *)((DMA\_HandleTypeDef *)hdma)-\/>Parent;}
\DoxyCodeLine{03656 }
\DoxyCodeLine{03657   \textcolor{comment}{/* Set ADC state */}}
\DoxyCodeLine{03658   SET\_BIT(hadc-\/>State, HAL\_ADC\_STATE\_ERROR\_DMA);}
\DoxyCodeLine{03659 }
\DoxyCodeLine{03660   \textcolor{comment}{/* Set ADC error code to DMA error */}}
\DoxyCodeLine{03661   SET\_BIT(hadc-\/>ErrorCode, HAL\_ADC\_ERROR\_DMA);}
\DoxyCodeLine{03662 }
\DoxyCodeLine{03663   \textcolor{comment}{/* Error callback */}}
\DoxyCodeLine{03664 \textcolor{preprocessor}{\#if (USE\_HAL\_ADC\_REGISTER\_CALLBACKS == 1)}}
\DoxyCodeLine{03665   hadc-\/>ErrorCallback(hadc);}
\DoxyCodeLine{03666 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{03667   HAL\_ADC\_ErrorCallback(hadc);}
\DoxyCodeLine{03668 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* USE\_HAL\_ADC\_REGISTER\_CALLBACKS */}\textcolor{preprocessor}{}}
\DoxyCodeLine{03669 \}}
\DoxyCodeLine{03670 }
\DoxyCodeLine{03675 \textcolor{preprocessor}{\#endif }\textcolor{comment}{/* HAL\_ADC\_MODULE\_ENABLED */}\textcolor{preprocessor}{}}

\end{DoxyCode}
